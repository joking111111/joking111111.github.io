<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JoKing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JoKing">
<meta property="og:url" content="https://joking111111.github.io/index.html">
<meta property="og:site_name" content="JoKing">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JoKing">
  
    <link rel="alternate" href="/atom.xml" title="JoKing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoKing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://joking111111.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CoordinatorLayout的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/27/CoordinatorLayout的使用/" class="article-date">
  <time datetime="2017-11-27T13:45:51.000Z" itemprop="datePublished">2017-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/27/CoordinatorLayout的使用/">CoordinatorLayout的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1-什么是嵌套滚动机制（NestedScrolling）？"><a href="#1-什么是嵌套滚动机制（NestedScrolling）？" class="headerlink" title="1.什么是嵌套滚动机制（NestedScrolling）？"></a>1.什么是嵌套滚动机制（NestedScrolling）？</h3><p>所谓嵌套滚动其实就是界面布局中包含 一个可滚动的列表 和 一个不可滚动的View，这样在滚动列表时，首先将不可滚动View移出屏幕或移进屏幕，待不可滚动View固定时，才会继续滚动滚动列表的内容。</p>
<h3 id="2-为什么要有滑动嵌套机制？"><a href="#2-为什么要有滑动嵌套机制？" class="headerlink" title="2.为什么要有滑动嵌套机制？"></a>2.为什么要有滑动嵌套机制？</h3><p>回想一下android系统事件分发机制，一个down事件到up事件为一个事件流，在这事件流之中一旦某个View拦截（处理）该Touch事件，那么后续这个事件流将统一交由它处理。</p>
<p>有时候我们需要将一个事件流分开成几个事件片给不同的View处理，那么我们需要调配事件分发。滑动嵌套机制应运而生。</p>
<h2 id="二、Android嵌套滚动机制"><a href="#二、Android嵌套滚动机制" class="headerlink" title="二、Android嵌套滚动机制"></a>二、Android嵌套滚动机制</h2><h3 id="1-重要的类"><a href="#1-重要的类" class="headerlink" title="1.重要的类"></a>1.重要的类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NestedScrollingChild接口</div><div class="line">NestedScrollingParent接口</div><div class="line">NestedScrollingChildHelper辅助类</div><div class="line">NestedScrollingParentHelper辅助类</div></pre></td></tr></table></figure>
<h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2.结构图"></a>2.结构图</h3><p><img src="/2017/11/27/CoordinatorLayout的使用/结构图.png" alt="结构图"></p>
<h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><h3 id="1-子类宽高"><a href="#1-子类宽高" class="headerlink" title="1.子类宽高"></a>1.子类宽高</h3><p>由于CoordinatorLayout是FrameLayout的增强版（官方文档），所以子View使用match_parent这个属性就需要注意了。</p>
<p>如下图，View B使用了match_parent，然后CoordinatorLayout在layout的时候把它的位置下移了，并且超出CoordinatorLayout的区域了。使用clipChildren属性是无效的，clipChildren默认是true的。<br><img src="/2017/11/27/CoordinatorLayout的使用/layout.png" alt="layout"></p>
<h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/GDC3YLLPYsoalr8sg38dmg" target="_blank" rel="external">CoordinatorLayout和Behavior详解</a></li>
<li><a href="https://mp.weixin.qq.com/s/-ldKAMGChfbvk8E8nzvuNw" target="_blank" rel="external">CoordinatorLayout高级用法-自定义Behavior</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/27/CoordinatorLayout的使用/" data-id="cjawlhnzl0005l3vf5a1hxvrs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Android卷一笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/25/深入理解Android卷一笔记/" class="article-date">
  <time datetime="2017-11-25T14:52:35.000Z" itemprop="datePublished">2017-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/25/深入理解Android卷一笔记/">深入理解Android卷一笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、JNI调用流程分析"><a href="#一、JNI调用流程分析" class="headerlink" title="一、JNI调用流程分析"></a>一、JNI调用流程分析</h2><h3 id="1-Java层"><a href="#1-Java层" class="headerlink" title="1.Java层"></a>1.Java层</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MediaScanner &#123;</div><div class="line">	static &#123;</div><div class="line">		System.loadLibrary(&quot;media_jni&quot;);</div><div class="line">		native_init();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private static native void native_init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>加载对应的JNI库。</li>
<li>声明native函数。</li>
</ul>
<h3 id="2-JNI层"><a href="#2-JNI层" class="headerlink" title="2.JNI层"></a>2.JNI层</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//cpp</div><div class="line">static void android_media_MediaScanner_native_init(JNIEnv *env) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么Java层调用native函数，系统是如何找到JNI层的对应函数的呢？</p>
<h4 id="一、静态注册"><a href="#一、静态注册" class="headerlink" title="一、静态注册"></a>一、静态注册</h4><p>流程：</p>
<ul>
<li>编写java层native函数声明，并javac编译为class文件。</li>
<li>使用<code>javah -o output packagename.classname</code>生成.h头文件。</li>
<li>JNI层cpp或者c文件实现该头文件。</li>
</ul>
<p>当Java层第一次调用该native方法时，jvm会从对应库找对应的头文件。如果找到，保存这个函数指针供下次调用；如果没找到就抛异常。</p>
<p>弊端：</p>
<ul>
<li>修改Java层的native方式后需要重新生成头文件，因为函数签名可能改变了。</li>
<li>初次调用native函数才会去建立关联，有懒加载特性，有利有弊。</li>
</ul>
<h4 id="二、动态注册"><a href="#二、动态注册" class="headerlink" title="二、动态注册"></a>二、动态注册</h4><p>JNI中有一个数据结构专门来记录这种一一对应关系的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">	const char* signature;</div><div class="line">	void* fnPtr;</div><div class="line">&#125; JNINativeMethod;</div></pre></td></tr></table></figure>
<p>AndroidRunTime.cpp提供了registerNativeMethods方法来注册；其中又通过JNIHelp.c的jniRegisterNativeMethods。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jclass clazz = (*env) -&gt; FindClass(env, className);</div><div class="line">(*env) -&gt; RegisterNatives(env, clazz, gMethods, numMethods);</div></pre></td></tr></table></figure>
<ul>
<li>1.当Java层通过System.loadLibrary加载so库时，会先找是否有JNI_OnLoad函数，如果有就调用它；</li>
<li>2.动态注册调用一般写在这个函数里。</li>
</ul>
<p>提示：<br>Android提供了JNIHelp.h这个文件，它内部包含了jni.h，所以我们编写jni时可以直接引入JNIHelp.h。</p>
<h3 id="4-什么是JNIEnv？"><a href="#4-什么是JNIEnv？" class="headerlink" title="4.什么是JNIEnv？"></a>4.什么是JNIEnv？</h3><p>JNIEnv是一个与线程相关的代表JNI环境的结构体。我们经常通过它来从native层回调java层函数，但由于它是线程相关的，所以我们不能在B线程调用A线程的JNIEnv。</p>
<h3 id="5-什么是JavaVM？"><a href="#5-什么是JavaVM？" class="headerlink" title="5.什么是JavaVM？"></a>5.什么是JavaVM？</h3><p>JavaVM顾名思义，就是一个java虚拟机变量，可以比作进程。不管有多少个线程，单进程就单独一个JavaVM。在JNI_OnLoad函数可以获得JavaVM。</p>
<ul>
<li>调用JavaVM-&gt;AttachCurrentThread可以获得当前线程的JNIEnv，这样可以在子线程回调java层函数。</li>
<li>在线程结束时，调用JavaVM-&gt;DetachCurrentThread来释放相关资源。</li>
</ul>
<h3 id="6-什么是jfieldID和jmethodID？"><a href="#6-什么是jfieldID和jmethodID？" class="headerlink" title="6.什么是jfieldID和jmethodID？"></a>6.什么是jfieldID和jmethodID？</h3><p>1.获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">jfieldID GetFieldID (jclass clazz, const char* name, const char* sig);</div><div class="line">jmethodID GetMethodID (jclass clazz, const char* name, const char* sig);</div></pre></td></tr></table></figure>
<p>建议在初始化的时候获取并保存下来，提高下一次调用的运行效率。</p>
<p>2.使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">NativeType Call&lt;type&gt;Method (jobject jobj, jmethodID methodID, ...);</div><div class="line">NativeType CallStatic&lt;type&gt;Method (jmethodID methodID, ...);</div><div class="line"></div><div class="line">NativeType Get&lt;type&gt;Field (jobject jobj, jfieldID fieldID);</div><div class="line">void Set&lt;type&gt;Field (jobject jobj, jfieldID fieldID, NativeType value);</div></pre></td></tr></table></figure>
<h3 id="7-jstring"><a href="#7-jstring" class="headerlink" title="7.jstring"></a>7.jstring</h3><p>1.java层String与native层string的转换关系：<br><img src="/2017/11/25/深入理解Android卷一笔记/jstring.png" alt="jstring"></p>
<p>2.释放资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">void ReleaseStringChars(jstring str, char* chs);</div><div class="line">void ReleaseStringUTFChars(jstring str, char* chs);</div></pre></td></tr></table></figure>
<p>转换字符串和释放资源方法应该是成对出现的。</p>
<h3 id="8-JNI类型签名"><a href="#8-JNI类型签名" class="headerlink" title="8.JNI类型签名"></a>8.JNI类型签名</h3><p>命令：<code>javap -s -p xxx.class</code></p>
<p>意义：</p>
<ul>
<li>-s 表示输出内部数据类型的签名信息。 </li>
<li>-p 表示打印所有函数和成员的签名信息。默认只打印public级别。</li>
</ul>
<h3 id="9-引用"><a href="#9-引用" class="headerlink" title="9.引用"></a>9.引用</h3><p>类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.Local Reference 本地变量</div><div class="line">2.Global Reference 全局变量（强印用）</div><div class="line">3.Weak Global Reference 弱全局变量</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">NewGlobalRef(NativeType ref);</div><div class="line">NewWeakGlobalRef(NativeType ref);</div><div class="line"></div><div class="line">DeleteLoaclRef(NativeType ref);</div><div class="line">DeleteGlobalRef(NativeType ref);</div><div class="line">DeleteWeakGlobalRef(NativeType ref);</div></pre></td></tr></table></figure>
<p>有时候我们可能创建太多LocalReference，这样内存占用可观，可以在方法结束调用前，提前手动回收LocalReference。</p>
<h3 id="10-异常"><a href="#10-异常" class="headerlink" title="10.异常"></a>10.异常</h3><p>JNI层可以截获和修改异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">ExceptionOccured 判断是否发生异常</div><div class="line">ExceptionClear 清空当前JNI发生的异常</div><div class="line">ThrowNew 向java层抛异常</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/25/深入理解Android卷一笔记/" data-id="cjawlho0c001el3vfrsz3vp1n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-Java笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Effective-Java笔记/" class="article-date">
  <time datetime="2017-11-23T14:42:17.000Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/23/Effective-Java笔记/">Effective Java笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、创建和销毁对象"><a href="#一、创建和销毁对象" class="headerlink" title="一、创建和销毁对象"></a>一、创建和销毁对象</h2><h3 id="1-静态工厂方法和公有构造函数"><a href="#1-静态工厂方法和公有构造函数" class="headerlink" title="1.静态工厂方法和公有构造函数"></a>1.静态工厂方法和公有构造函数</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static Boolean valueOf(boolean b) &#123;</div><div class="line">	return b ? Boolean.TRUE : Boolean.FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>静态工厂方法名相对构造函数，方便指示使用者选择合适的方法。</li>
<li>静态工厂方法可以控制不创建新对象，而是重复使用一些对象。如示例代码所示。</li>
<li>静态工厂方法可返回返回类型的子类对象，设计模式中的工厂模式。</li>
</ul>
<p>缺点：</p>
<ul>
<li>静态工厂方法一般会把构造函数非公有，导致类不能被继承。但是这样鼓励我们使用组合而非继承。</li>
</ul>
<p>总结：</p>
<ul>
<li>如果需要重用对象（单例），请使用静态工厂方法。</li>
<li>如果需要提供不同的具体实现（子类），或者说面向接口编程，请使用静态工厂方法。</li>
</ul>
<h3 id="2-多个构造函数与Builder（构建者）"><a href="#2-多个构造函数与Builder（构建者）" class="headerlink" title="2.多个构造函数与Builder（构建者）"></a>2.多个构造函数与Builder（构建者）</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public MyView(Context context) &#123;</div><div class="line">       this(context, 100, 100);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyView(Context context, int width, int height) &#123;</div><div class="line">       this(context, width, height);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyView(Context context, int width, int height, int margin) &#123;</div><div class="line">		...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像这种参数比较多，并且有可选参数时，建议使用Builder模式。<br>另外，Builder不建议使用Java Bean的getter、setter形式，建议使用链式调用写法，代码更简洁。</p>
<p>优点：</p>
<ul>
<li>将传入的参数处理职责分离出去，类专注于功能，Builder专注于构建类参数，这样代码可读性跟拓展性增强。</li>
</ul>
<h3 id="3-避免创建不必要的对象"><a href="#3-避免创建不必要的对象" class="headerlink" title="3.避免创建不必要的对象"></a>3.避免创建不必要的对象</h3><p>比如SimpleDateFormat对象。</p>
<h3 id="4-清除过期的对象引用"><a href="#4-清除过期的对象引用" class="headerlink" title="4.清除过期的对象引用"></a>4.清除过期的对象引用</h3><ul>
<li>适当的时候将引用置为null。</li>
<li>使用WeakReference。</li>
</ul>
<h3 id="5-避免使用finalize方法"><a href="#5-避免使用finalize方法" class="headerlink" title="5.避免使用finalize方法"></a>5.避免使用finalize方法</h3><p>原因：</p>
<ul>
<li>jvm不保证对象的finalize方法及时执行。</li>
<li>jvm不保证对象的finalize方法一定执行。</li>
</ul>
<p>建议：</p>
<ul>
<li>在适当的时机，如try-catch中finally代码块调用close、recycle等方法。</li>
</ul>
<h2 id="二、方法的实现"><a href="#二、方法的实现" class="headerlink" title="二、方法的实现"></a>二、方法的实现</h2><h3 id="1-重写equals"><a href="#1-重写equals" class="headerlink" title="1.重写equals"></a>1.重写equals</h3><p>性质：</p>
<ul>
<li>自反性（reflexive） x.equals(x) = true</li>
<li>对称性（symmetric） x.equals(y) &lt;=&gt; y.equals(x)</li>
<li>传递性（transitive） x.equals(y) = y.equals(z) 那么 x.equals(z)结果应为一样</li>
<li>一致性（consistent）x,y不变时，x.equals(y)也不变</li>
<li>非null的x，x.equals(null) = false</li>
</ul>
<p>由于参数固定为Object类型（否则就是方法重载了），有必要做类型检查（instanceOf）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean equals(Object o) &#123;</div><div class="line">       return super.equals(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-重写hashCode"><a href="#2-重写hashCode" class="headerlink" title="2.重写hashCode"></a>2.重写hashCode</h3><p>重写了equals方法后，最好也重写hashCode方法。</p>
<p>原因：</p>
<ul>
<li>两个对象equals方法返回true，不代表两个对象的hashCode返回值相等。</li>
<li>默认hashCode本质上是这个对象的散列值，是以整个对象所有对象生成的，而我们重写equals方法可能只用到对象的关键成员，并不是全体成员。</li>
</ul>
<p>常用的类比如HashMap，我们使用自定义的类作为key时，HashMap会调用key的hashCode方法作为判定key相等的依据之一，并不是重写了equals方法就万事大吉了。</p>
<h3 id="3-重写toString"><a href="#3-重写toString" class="headerlink" title="3.重写toString"></a>3.重写toString</h3><p>可以准备好一份模版或者使用脚本，生成toString函数。<br>比如可以利用toString将Java Bean转换为json字符串。</p>
<h2 id="三、类和接口"><a href="#三、类和接口" class="headerlink" title="三、类和接口"></a>三、类和接口</h2><h3 id="1-组合优于继承"><a href="#1-组合优于继承" class="headerlink" title="1.组合优于继承"></a>1.组合优于继承</h3><p>对于接口的实现和继承不适用这条。</p>
<p>父类有可能因为版本迭代而修改某些方法，这样子类很可能也要做出改变，但是我们可能对具体实现不敏感，只是想增加额外方法。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 接口定义</div><div class="line">*/</div><div class="line">public interface PriceCalculator &#123;</div><div class="line">	float getPrice(int sum);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 包装类</div><div class="line">*/</div><div class="line">public PriceCalculatorWrapper implements PriceCalculator &#123;</div><div class="line">	private PriceCalculator mCalculator;</div><div class="line">	</div><div class="line">	//唯一构造函数</div><div class="line">	public PriceCalculatorWrapper(PriceCalculator calculator) &#123;</div><div class="line">		this.mCalculator = calculator;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@override</div><div class="line">	public float getPrice(int sum) &#123;</div><div class="line">		return mCalculator.getPrice(sum);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 具体实现类</div><div class="line">*/</div><div class="line">public ShopPriceCalculator implements PriceCalculator &#123;</div><div class="line">	@override</div><div class="line">	public float getPrice(int sum) &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以跟设计模式中的策略模式关联起来。</p>
<h3 id="2-接口优于抽象类"><a href="#2-接口优于抽象类" class="headerlink" title="2.接口优于抽象类"></a>2.接口优于抽象类</h3><ul>
<li>一个类能实现多个接口，只能继承一个类。</li>
<li>面向接口编程，外界知道得越少越好。</li>
<li>接口定义了一类方法的集合，做一件事可能有几个步骤，但是是通过一个接口完成的。</li>
</ul>
<h3 id="3-接口最好只定义方法"><a href="#3-接口最好只定义方法" class="headerlink" title="3.接口最好只定义方法"></a>3.接口最好只定义方法</h3><p>接口虽然可以有静态常量成员变量，但是并不是每个接口的实现类都会用到这些变量。虽然这并不影响运行效率，但是从代码可读性而言，在接口定义静态常量成员变量不是明智之举。</p>
<h3 id="4-使用函数对象实现策略模式"><a href="#4-使用函数对象实现策略模式" class="headerlink" title="4.使用函数对象实现策略模式"></a>4.使用函数对象实现策略模式</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">interface Comparator&lt;T&gt; &#123;</div><div class="line">	int compare(T t1, T t2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class StringLengthComparator implements Comparator&lt;String&gt; &#123;</div><div class="line">	@override</div><div class="line">	public int compare(String s1, String s2) &#123;</div><div class="line">		return s1.length() - s2.length();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//每一次排序均要创建一个比较函数对象</div><div class="line">Array.sort(stringArray, new StringLengthComparator());</div></pre></td></tr></table></figure>
<p>C++支持函数指针，即把一个函数体用指针作为参数传入别的作用域。这样可以达到面向接口编程的效果，不关注方法的具体实现。而java中，最相似的案例就是回调监听的实现了，只不过java没有指针，而是通过一个实现了监听接口的对象来传入别的作用域。</p>
<p>由于策略模式的方法具体实现是无状态的（上一次调用与下一次调用无关），所以可以考虑将函数对象做成单例。</p>
<p>建议：</p>
<ul>
<li>如果需要频繁使用该函数，那么最好做成一个单例，而不是每一次都创建新对象。</li>
<li>如果使用次数不多，做成单例会导致函数对象生命周期过长，对于内存敏感的程序要慎重，虽然这个单例占用内存可能不多。</li>
</ul>
<h3 id="5-慎用非静态内部类"><a href="#5-慎用非静态内部类" class="headerlink" title="5.慎用非静态内部类"></a>5.慎用非静态内部类</h3><p>匿名内部类也属于非静态内部类。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivty extends ... &#123;</div><div class="line">	public void work() &#123;</div><div class="line">		new Thread() &#123;</div><div class="line">			Toast.makeText(MainActivity.this, &quot;hello world&quot; ,Toast.LENGTH_SHORT);</div><div class="line">			//do something</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在work函数里面，创建了一个匿名内部类，它持有了外部类的强引用（MainActivity.this）。如果内部类的生命周期比外部类长的话，就会发生内存泄漏。</p>
<p>不仅是内存泄漏，由于内部类有外部类的强引用，也会占用一定内存空间。比如HashMap中的Entry如果不是静态内部类，那么每个Entry都会拥有HashMap的强引用，一旦节点数量多了，也会影响性能。</p>
<p>建议：</p>
<ul>
<li>如果不需要外部类的引用（调用方法），请加上static关键字修饰内部类。</li>
<li>如果需要使用非静态内部类，请谨慎管理非静态内部类对象的生命周期。</li>
</ul>
<h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="1-不要使用原生态类型"><a href="#1-不要使用原生态类型" class="headerlink" title="1.不要使用原生态类型"></a>1.不要使用原生态类型</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//原生态类型</div><div class="line">List list = new ArrayList();</div><div class="line"></div><div class="line">//非原生态类型</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">--------------------------------------------------------------------</div><div class="line"></div><div class="line">//错误代码</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">unsafeAdd(list, new Integer(1));</div><div class="line">//crash</div><div class="line">list.get(0);</div><div class="line"></div><div class="line">--------------------------------------------------------------------</div><div class="line">public static void unsafeAdd(List list, Object o)&#123;</div><div class="line">	list.add(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>unsafeAdd方法参数list使用了原生态类型，并没有对插入元素做类型检查。所以在编译期不会报错。</li>
<li>等到调用了get方法时，程序尝试将Integer强转为String，抛出异常。</li>
</ul>
<p>注意！有两种特殊情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//1.获取class类</div><div class="line">List.class,String[].class,int.class 合法</div><div class="line">List&lt;String&gt;,List&lt;?&gt;.class 不合法</div><div class="line"></div><div class="line">//2.类型判定</div><div class="line">if (o instanceOf Set) &#123;</div><div class="line">	Set&lt;?&gt; set = (Set&lt;?&gt;) o;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：<br>我们应该使用带泛型参数的类，让编译器帮助我们暴露程序的问题，而不是等到程序运行异常才暴露问题。</p>
<h3 id="2-泛型列表优于泛型数组"><a href="#2-泛型列表优于泛型数组" class="headerlink" title="2.泛型列表优于泛型数组"></a>2.泛型列表优于泛型数组</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//运行时报错</div><div class="line">Object[] objects = new Long[1];</div><div class="line">objects[0] = &quot;hello world&quot;;</div><div class="line"></div><div class="line">//编译不通过</div><div class="line">List&lt;Object&gt; list = new ArrayList&lt;Long&gt;();</div><div class="line">list.add(&quot;hello world&quot;);</div></pre></td></tr></table></figure>
<p>原因：</p>
<ul>
<li>Object[]是Long[]的父类，因此分配内存给objects时不会抛异常。</li>
<li>List<object>并不是ArrayList<long>的父类，也不是List<long>的父类，所以编译不通过。</long></long></object></li>
<li>Java泛型使用的是类型擦除机制实现泛型的，运行时把具体类型替换掉。编译期在编译时会做类型检查，这也是使用非原生态类型的好处。</li>
</ul>
<h2 id="五、枚举和注解"><a href="#五、枚举和注解" class="headerlink" title="五、枚举和注解"></a>五、枚举和注解</h2><h3 id="1-用enum代替int常量"><a href="#1-用enum代替int常量" class="headerlink" title="1.用enum代替int常量"></a>1.用enum代替int常量</h3><p>Java枚举类型基本想法：通过public static final为每个枚举常量导出实例的类。</p>
<ul>
<li>枚举没有公有构造函数，所以程序员无法手动创建枚举实例。</li>
<li>枚举是线程安全的（final），也是防序列化反序列化的，很适合做单例。</li>
<li>枚举常量是一个个对象，功能上肯定比一个int常量要强多了，相对的开销也大了。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public enum Sample &#123;</div><div class="line">	SOLO(1), DUET(2), TRIO(3);</div><div class="line">	</div><div class="line">	private final int order;</div><div class="line">	Sample(int order) &#123;</div><div class="line">		this.order = order;</div><div class="line">	&#125;</div><div class="line">	public int getOrder() &#123;</div><div class="line">		return order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要使用默认顺序和ordinal()函数，而是使用一个成员变量记录序号。因为这样便于维护和检查。</p>
<h3 id="2-坚持使用override注解"><a href="#2-坚持使用override注解" class="headerlink" title="2.坚持使用override注解"></a>2.坚持使用override注解</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	private int order;</div><div class="line">	public boolean equals (Test t) &#123;</div><div class="line">		return this.order == t.order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>equals没有使用override注解，导致编译期编译时没有“检查”。事实上，这个equals方法看似是重写，实际上是重载。因为equals方法原型是<code>public boolean equals(Object o)</code>。</p>
<h3 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3.常用注解"></a>3.常用注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@callSuper //声明子类若重写该方法，必须调用父类方法</div></pre></td></tr></table></figure>
<h2 id="六、函数方法"><a href="#六、函数方法" class="headerlink" title="六、函数方法"></a>六、函数方法</h2><h3 id="1-必要时进行保护性拷贝"><a href="#1-必要时进行保护性拷贝" class="headerlink" title="1.必要时进行保护性拷贝"></a>1.必要时进行保护性拷贝</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Adapter &#123;</div><div class="line">	private List&lt;String&gt; mList;</div><div class="line">	public Adapter(List&lt;String&gt; list) &#123;</div><div class="line">		mList = list;//没有保护性拷贝</div><div class="line">		mList = new ArrayList(list);//进行保护性拷贝</div><div class="line">		...</div><div class="line">		//检查参数有效性</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一条主要按业务逻辑分的，如果想共用同一个参数对象，那么保存它的引用就好，否则我们应该新创建一个对象对参数对象进行拷贝。</p>
<p>保护性拷贝场景：</p>
<ul>
<li>不希望参数对象在类外部变化时能影响类时。</li>
<li>对并发场景有要求。</li>
</ul>
<h3 id="2-检查参数有效性"><a href="#2-检查参数有效性" class="headerlink" title="2.检查参数有效性"></a>2.检查参数有效性</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@override</div><div class="line">public boolean equals(Object o) &#123;</div><div class="line">	if(o instanceOf String) &#123;</div><div class="line">		String s = (String) o;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查参数有效性一般在保护性拷贝之后。方法调用前检查参数合法性，减少调试的复杂性。</p>
<h3 id="3-谨慎增加快捷方法"><a href="#3-谨慎增加快捷方法" class="headerlink" title="3.谨慎增加快捷方法"></a>3.谨慎增加快捷方法</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void showWindow(int width, int height, long time) &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">//快捷方法，宽高默认100</div><div class="line">public void showWindow(long time) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除非快捷方法经常被调用，否则最好不要写快捷方法。因为增加快捷方法会使类的方法数上升，对于用户的理解难度相对增加；对于维护者，增加了维护默认参数和文档的职责。</p>
<h3 id="4-谨慎使用重载"><a href="#4-谨慎使用重载" class="headerlink" title="4.谨慎使用重载"></a>4.谨慎使用重载</h3><p>这里需要强调重载和重写的运行时机区别：</p>
<ul>
<li>重载方法运行时机是在编译期确定好的，一个参数对象编译期是什么类型，决定了它会走哪个重载方法，并不会它运行时是子类对象而发生改变。</li>
<li>重写方法运行时机是在运行时才确定的，是根据对象的实际类型决定走哪个类的重写方法，不受编译时类型影响。</li>
</ul>
<h3 id="5-谨慎使用可变参数"><a href="#5-谨慎使用可变参数" class="headerlink" title="5.谨慎使用可变参数"></a>5.谨慎使用可变参数</h3><p>弊端：</p>
<ul>
<li>方法调用前得检查参数有效性稍麻烦。</li>
<li>可变参数方法的每次调用都会导致进行一次数组分配和初始化。</li>
</ul>
<p>建议：</p>
<ul>
<li>根据调用频率，给频率高的方法提供单独方法，对于频率低的可以使用可变参数方法。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void foo() &#123; &#125;</div><div class="line">public void foo(int a1) &#123; &#125;</div><div class="line">public void foo(int a1, int a2) &#123; &#125;</div><div class="line">public void foo(int a1, int a2, int a3) &#123; &#125;</div><div class="line">public void foo(int a1, int a2, int a3, int... rest) &#123; &#125;</div></pre></td></tr></table></figure>
<h3 id="6-返回长度为零的数组或集合，而不是null"><a href="#6-返回长度为零的数组或集合，而不是null" class="headerlink" title="6.返回长度为零的数组或集合，而不是null"></a>6.返回长度为零的数组或集合，而不是null</h3><p>原因：</p>
<ul>
<li>返回null调用者需要对null作额外处理。当然调用者也需要对零长度作处理。</li>
<li>零长度的数组或集合创建开销并不大。</li>
<li>零长度的数组属于不可变的（final），可以共享。</li>
</ul>
<h2 id="七、通用程序设计"><a href="#七、通用程序设计" class="headerlink" title="七、通用程序设计"></a>七、通用程序设计</h2><h3 id="1-尽量使用for-each而不是for循环和使用Iterator"><a href="#1-尽量使用for-each而不是for循环和使用Iterator" class="headerlink" title="1.尽量使用for-each而不是for循环和使用Iterator"></a>1.尽量使用for-each而不是for循环和使用Iterator</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//for-each</div><div class="line">for(String s : list) &#123;</div><div class="line">	doSomething(s);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//for循环</div><div class="line">for(int i = 0;i &lt; a.length; i++) &#123;</div><div class="line">	doSomething(a[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Iterator</div><div class="line">for(Iterator&lt;String&gt; i = list.iterator(); i.hasNext(); ) &#123;</div><div class="line">	doSomething(i.next());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>代码简洁。</li>
<li>性能较好，只计算一次size。</li>
</ul>
<h3 id="2-基本类型优于装箱基本类型"><a href="#2-基本类型优于装箱基本类型" class="headerlink" title="2.基本类型优于装箱基本类型"></a>2.基本类型优于装箱基本类型</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//自动装箱</div><div class="line">Integer integer = 10;</div><div class="line">//自动拆箱</div><div class="line">int i = integer;</div></pre></td></tr></table></figure>
<p>对照关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">byte - Byte</div><div class="line">int - Integer</div><div class="line">long - Long</div><div class="line">boolean - Boolean</div><div class="line">float - Float</div><div class="line">double - Double</div></pre></td></tr></table></figure>
<ul>
<li><p>自动装箱是基本数据类型自动转换为装箱基本类型，是java语法糖。它伴随着新对象的生成，当然有性能损耗。</p>
</li>
<li><p>自动拆箱是调用装箱基本类型对象的取值方法。</p>
</li>
</ul>
<h3 id="3-如果需要精确值，避免使用float和double"><a href="#3-如果需要精确值，避免使用float和double" class="headerlink" title="3.如果需要精确值，避免使用float和double"></a>3.如果需要精确值，避免使用float和double</h3><ul>
<li><p>float和double执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。</p>
</li>
<li><p>然而他们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。</p>
</li>
</ul>
<p>需要准确结果，请使用BigDecimal类，它额外提供了几种四舍五入的模式。</p>
<h3 id="4-慎用String连接"><a href="#4-慎用String连接" class="headerlink" title="4.慎用String连接"></a>4.慎用String连接</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot; + &quot;world&quot;;</div></pre></td></tr></table></figure>
<p>这里涉及到三个对象生成。</p>
<ul>
<li><p>String是不可变的（final），一旦一个String对象生成，它本身是不会发生改变的。</p>
</li>
<li><p>String相加其实是语法糖，运算符重载。</p>
</li>
<li><p>三个对象分别为”hello”、”world”、”helloworld”。</p>
</li>
</ul>
<h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h3 id="1-不要滥用异常机制"><a href="#1-不要滥用异常机制" class="headerlink" title="1.不要滥用异常机制"></a>1.不要滥用异常机制</h3><p>有时代码抛出异常，如果无法快速找到修复方法，我们为了尽快修复，可能会使用try-catch来暂时避免程序崩溃。我们应尽量不使用try-catch来捕获处理异常，而是通过代码逻辑来判断异常发生。</p>
<h3 id="2-使用try-catch时，请尽量缩小代码块范围"><a href="#2-使用try-catch时，请尽量缩小代码块范围" class="headerlink" title="2.使用try-catch时，请尽量缩小代码块范围"></a>2.使用try-catch时，请尽量缩小代码块范围</h3><p>异常机制是在jvm层面实现的，try-catch代码块会阻止jvm执行某些特定优化，导致程序运行效率下降。</p>
<p>最常见的情况就是打开文件做文件操作时，某些程序员为了省事直接用try-catch把方法开始到方法结束包住，因为他们并不知道这样的写法会导致程序运行效率下降。</p>
<p>正确的做法应该是尽量减少try-catch代码块的长度，宁愿多用几个try-catch代码块，也不要一个try-catch代码块将全部代码包住。</p>
<h3 id="3-throw明确异常，catch明确异常"><a href="#3-throw明确异常，catch明确异常" class="headerlink" title="3.throw明确异常，catch明确异常"></a>3.throw明确异常，catch明确异常</h3><p>对异常进行分类抛出和处理，便于日后维护。</p>
<h2 id="九、序列化"><a href="#九、序列化" class="headerlink" title="九、序列化"></a>九、序列化</h2><h3 id="1-Serializable"><a href="#1-Serializable" class="headerlink" title="1.Serializable"></a>1.Serializable</h3><p>需要序列化的类（如java bean）才实现Serializable，因为实现一个接口总是有代价的。</p>
<h3 id="2-Parcelable"><a href="#2-Parcelable" class="headerlink" title="2.Parcelable"></a>2.Parcelable</h3><p>这个接口是android特有的，出现的原因之一是解决因为本地序列化反序列化耗时较长导致某些重要操作耗时变长。它不能本地化（序列化到本地文件），而是序列化到内存中。相对于Serializable，其实不能相提并论，因为使用场景不一样。</p>
<p>比如，Activity#onSaveInstanceState(Bundle state)、Activity#onRestoreInstanceState(Bundle state)这两个方法，需要对Activity的状态保存或重建，对速度要求高，对本地化存储没有要求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/23/Effective-Java笔记/" data-id="cjawlhnzj0004l3vfr0iuo5bb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Glide笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/Glide笔记/" class="article-date">
  <time datetime="2017-11-19T06:23:15.000Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/Glide笔记/">Glide笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-基本组件"><a href="#一-基本组件" class="headerlink" title="一.基本组件"></a>一.基本组件</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><p>以下均基于Glide4.x版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//加载图片</div><div class="line">Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options)</div><div class="line">.into(imageView);</div><div class="line"></div><div class="line">//取消加载</div><div class="line">Glide.with(getContext())</div><div class="line">.clear(imageView);</div></pre></td></tr></table></figure>
<h3 id="2-RequestOptions"><a href="#2-RequestOptions" class="headerlink" title="2.RequestOptions"></a>2.RequestOptions</h3><p>Glide的常用选项</p>
<ul>
<li>裁剪样式circleCrop、circleCrop等。</li>
<li>加载中占位图placeholder</li>
<li>加载失败图error</li>
<li>…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RequestOptions centerCropOptions = new RequestOptions()</div><div class="line">            .centerCrop()</div><div class="line">            .placeholder(R.drawable.img_loading)</div><div class="line">            .error(R.drawable.img_failed);</div></pre></td></tr></table></figure>
<h3 id="3-RequestBuilder"><a href="#3-RequestBuilder" class="headerlink" title="3.RequestBuilder"></a>3.RequestBuilder</h3><p>可以理解为一个个的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RequestBuilder builder = Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options);</div></pre></td></tr></table></figure>
<p>当调用RequestBuilder.into(target)时开始加载。这个方法的返回值类型不再是RequestBuilder了。</p>
<h2 id="二、常用操作"><a href="#二、常用操作" class="headerlink" title="二、常用操作"></a>二、常用操作</h2><h3 id="1-加载失败回调监听"><a href="#1-加载失败回调监听" class="headerlink" title="1.加载失败回调监听"></a>1.加载失败回调监听</h3><p>RequestBuilder.listen(RequestListener)方法监听load成功还是失败。</p>
<ul>
<li>注意这里不能在监听里对同一个target（imageView）发起加载请求，因为当前请求尚未结束，会抛出异常。</li>
<li>所以无法使用这个监听实现加载失败时加载备用url的需求。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options)</div><div class="line">.listener(new RequestListener() &#123;</div><div class="line">	@Override</div><div class="line">	public boolean onLoadFailed(@Nullable GlideException e, Object model, Target target, boolean isFirstResource) &#123;</div><div class="line">		//false：事件继续往下传递</div><div class="line">		//true：事件不再往下传递</div><div class="line">   		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public boolean onResourceReady(Object resource, Object model, Target target, DataSource dataSource, boolean isFirstResource) &#123;</div><div class="line">		//false：事件继续往下传递</div><div class="line">		//true：事件不再往下传递</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">.into(imageView);</div></pre></td></tr></table></figure>
<h3 id="2-请求失败后启用备用请求"><a href="#2-请求失败后启用备用请求" class="headerlink" title="2.请求失败后启用备用请求"></a>2.请求失败后启用备用请求</h3><p>RequestBuilder.error(RequestBuilder)方法可以在这个request失败后启用备用的request。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">RequestBuilder builder1 = Glide.with(getContext())</div><div class="line">.load(url1)</div><div class="line">.apply(options);</div><div class="line"></div><div class="line">RequestBuilder builder2 = Glide.with(getContext())</div><div class="line">.load(url2)</div><div class="line">.apply(options)</div><div class="line">.error(builder1);</div><div class="line"></div><div class="line">builder2.into(imageView);</div></pre></td></tr></table></figure>
<p>这段代码意义为当url2加载失败后，会启用builder1这个请求，加载url1。这样我们就可以实现多级url加载了。</p>
<p>以下为多级加载url方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void loadUrls(String[] urls, RequestOptions options, ImageView imageView) &#123;</div><div class="line">        if (urls == null || urls.length == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        RequestBuilder&lt;Drawable&gt; frontBuilder = Glide.with(getContext()).load(urls[0]).apply(options);</div><div class="line">        RequestBuilder&lt;Drawable&gt; prevBuilder = frontBuilder;</div><div class="line">        </div><div class="line">        for (int i = 1; i &lt; urls.length; i++) &#123;</div><div class="line">            RequestBuilder&lt;Drawable&gt; nextBuilder = Glide.with(getContext()).load(urls[i]).apply(options);</div><div class="line">            prevBuilder.error(nextBuilder);</div><div class="line">            prevBuilder = nextBuilder;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        frontBuilder.into(imageView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/19/Glide笔记/" data-id="cjawlhnzo0008l3vfwqz4feh7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android使用kotlin注意事项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/android使用kotlin注意事项/" class="article-date">
  <time datetime="2017-11-19T06:23:03.000Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/android使用kotlin注意事项/">android使用kotlin注意事项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、注意参数可空"><a href="#一、注意参数可空" class="headerlink" title="一、注意参数可空"></a>一、注意参数可空</h2><p>现在第三方库基本都用java写，使用kotlin调用三方库时，最常见的场景就是实现回调接口。实现回调接口的时候，注意接口方法参数如果可空一定要加上”?”修饰，否则崩溃时很难从日志发现问题所在。</p>
<ul>
<li>基本数据类型没必要加”?”，只有对象才需要加。</li>
<li>使用kotlin设计接口时也要注意这一点。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/19/android使用kotlin注意事项/" data-id="cjawlhnzu000kl3vf6jzgjrx8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-搭建基于hexo的博客以及如何迁移" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/09/搭建基于hexo的博客以及如何迁移/" class="article-date">
  <time datetime="2017-11-09T13:22:17.000Z" itemprop="datePublished">2017-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/09/搭建基于hexo的博客以及如何迁移/">搭建基于hexo的博客以及如何迁移</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、搭建环境"><a href="#一、搭建环境" class="headerlink" title="一、搭建环境"></a>一、搭建环境</h2><h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h3><h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h3><h3 id="3-检查版本"><a href="#3-检查版本" class="headerlink" title="3.检查版本"></a>3.检查版本</h3><p>以上安装可以通过Homebrew。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">npm -v</div><div class="line">git --version</div></pre></td></tr></table></figure>
<h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h3><p>终端所在位置就是安装位置。<br><code>npm install -g hexo-cli</code></p>
<h3 id="5-初始化本地博客"><a href="#5-初始化本地博客" class="headerlink" title="5.初始化本地博客"></a>5.初始化本地博客</h3><p>新建一个合适的文件夹如hexo。注意这个文件夹必须为空，否则提示错误。<br><code>hexo init hexo</code><br>期间请按照终端的提示操作就好了。</p>
<h2 id="二、hexo的使用"><a href="#二、hexo的使用" class="headerlink" title="二、hexo的使用"></a>二、hexo的使用</h2><h3 id="1-主要文件和目录"><a href="#1-主要文件和目录" class="headerlink" title="1.主要文件和目录"></a>1.主要文件和目录</h3><ul>
<li><code>_config.yml</code>这个文件是这个博客的配置文件。<br>具体看<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">官方文档</a>。</li>
<li>source文件夹<br>这个文件夹存放你写的md文件。我一般在github创建一个仓库，利用git进行管理。当然你的博客原文件将被看到，有被抄袭的风险。</li>
</ul>
<h3 id="2-使用命令"><a href="#2-使用命令" class="headerlink" title="2.使用命令"></a>2.使用命令</h3><ul>
<li><code>hexo n &quot;hello world&quot;</code>创建名为hello world的博客。</li>
<li><code>hexo g</code>hexo生成html等文件。</li>
<li><code>hexo s</code>hexo使用node.js运行本地服务器进行预览。<br>在命令行会看到预览地址，用浏览器打开就是了。命令行control+c退出本地服务器。</li>
</ul>
<h2 id="三、迁移博客"><a href="#三、迁移博客" class="headerlink" title="三、迁移博客"></a>三、迁移博客</h2><p><a href="https://www.zhihu.com/question/21193762/answer/103097754" target="_blank" rel="external">使用hexo，如果换了电脑怎么更新博客？ - skycrown的回答</a></p>
<h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><ul>
<li>《Android群英传 神兵利器》徐宜生著</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/09/搭建基于hexo的博客以及如何迁移/" data-id="cjawlho0b001bl3vf2kng9cey" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mac下配置zsh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/08/mac下配置zsh/" class="article-date">
  <time datetime="2017-11-08T01:09:06.000Z" itemprop="datePublished">2017-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/08/mac下配置zsh/">mac下配置zsh</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h2><p>以下安装请自行搜索。</p>
<ul>
<li>安装homebrew。</li>
<li>安装homebrew cask。</li>
</ul>
<h2 id="2-配置过程"><a href="#2-配置过程" class="headerlink" title="2.配置过程"></a>2.配置过程</h2><ul>
<li><p>安装brew上的zsh <code>brew install zsh</code></p>
</li>
<li><p>安装iterm2（可选，只是换更好用的终端） <code>brew cask install iterm2</code></p>
</li>
<li><p>切换到zsh<br><code>chsh -s /bin/zsh</code><br>如果要切换回来，执行<br><code>chsh -s /bin/bash</code><br>查看当前使用哪种shell<br><code>echo $SHELL</code></p>
</li>
</ul>
<h2 id="3-进阶配置"><a href="#3-进阶配置" class="headerlink" title="3.进阶配置"></a>3.进阶配置</h2><ul>
<li><p>下载oh-my-zsh，不需要设置哪个目录，新开一个终端就可以了。 <code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></p>
</li>
<li><p>拷贝出oh-my-zsh中的文件作为自己的配置文件 <code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></p>
</li>
<li><p>在.zshrc文件中，追加<code>source .bash_profile</code>保留以前配置的环境变量。</p>
</li>
<li><p>zsh还有许多拓展插件，详细可以查看<br><a href="https://github.com/zsh-users" target="_blank" rel="external">https://github.com/zsh-users</a>。</p>
</li>
</ul>
<h2 id="4-可能遇到的问题"><a href="#4-可能遇到的问题" class="headerlink" title="4.可能遇到的问题"></a>4.可能遇到的问题</h2><ul>
<li>没有.bash_profile文件，请自行创建一个。</li>
<li>没有.zshrc文件，请执行拷贝配置文件的命令。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/08/mac下配置zsh/" data-id="cjawlho040014l3vfm3y8124a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-常用Android工具命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/07/常用Android工具命令/" class="article-date">
  <time datetime="2017-11-07T01:02:57.000Z" itemprop="datePublished">2017-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/07/常用Android工具命令/">常用Android工具命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、Gradle"><a href="#一、Gradle" class="headerlink" title="一、Gradle"></a>一、Gradle</h2><ul>
<li>gradlew是gradle wrapper中的可执行命令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">1、查看gradle版本</div><div class="line">./gradlew -v</div><div class="line">  </div><div class="line">2、清空build文件夹下所有东西</div><div class="line">./gradlew clean</div><div class="line"></div><div class="line">3、检查依赖并编译打包。一般按照build type打出所有包</div><div class="line">./gradlew build</div><div class="line"></div><div class="line">4、打出Debug版本apk，文件在build/output/apk目录下,对应地有assmbleRelease命令</div><div class="line">./gradlew assembleDebug</div><div class="line"></div><div class="line">5、相比上一个命令，清理了编译缓存</div><div class="line">./gradlew clean assembleDebug</div><div class="line"></div><div class="line">6、Release模式打包并安装</div><div class="line">./gradlew installRelease</div><div class="line"></div><div class="line">7、卸载Release模式包</div><div class="line">./gradlew uninstallRelease</div></pre></td></tr></table></figure>
<h2 id="二、aapt"><a href="#二、aapt" class="headerlink" title="二、aapt"></a>二、aapt</h2><p>aapt全名android asset packaging tool。</p>
<ul>
<li>列举apk里有什么文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list可以简写为l</div><div class="line">aapt list [apk path]		在命令行输出</div><div class="line">appt list [apk path] &gt; [file path]		输出到文件</div></pre></td></tr></table></figure>
<ul>
<li>查看指定文件信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dump可以简写为d</div><div class="line">aapt dump [value] [apk path]</div><div class="line"></div><div class="line">value的取值有：</div><div class="line">badging</div><div class="line">permissions</div><div class="line">resources</div><div class="line">configurations</div><div class="line">xmltree</div><div class="line">xmlstrings</div><div class="line"></div><div class="line">xmltree,xmlstrings这两个value在命令后面需要加文件相对路径：</div><div class="line">aapt dump xmltree [apk path] [file path]</div></pre></td></tr></table></figure>
<ul>
<li>修改apk包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aapt package		打成压缩包</div><div class="line">aapt remove		从压缩包中删除</div><div class="line">aapt add		向压缩包添加指定文件</div></pre></td></tr></table></figure>
<ul>
<li>显示aapt工具的版本<code>aapt version</code></li>
</ul>
<h2 id="三、adb"><a href="#三、adb" class="headerlink" title="三、adb"></a>三、adb</h2><p>adb全名android debug bridge。<br>在不知道某个指令怎么使用时，如adb shell pm，在指令后加上help，这样会输出提示信息。</p>
<ul>
<li>常用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//进入shell模式</div><div class="line">adb shell</div><div class="line"></div><div class="line">//退出shell模式</div><div class="line">exit</div><div class="line"></div><div class="line">//查看连接上的devices</div><div class="line">adb devices</div><div class="line"></div><div class="line">//安装apk</div><div class="line">adb install -r &lt;path&gt;</div><div class="line"></div><div class="line">//从设备拉取文件</div><div class="line">adb pull &lt;remote&gt; &lt;local&gt;从设备拉取文件</div><div class="line"></div><div class="line">//推送文件到设备</div><div class="line">adb push &lt;local&gt; &lt;remote&gt;</div></pre></td></tr></table></figure>
<ul>
<li>无线调试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//获取设备IP，确保在同一局域网中</div><div class="line">设置-&gt;关于-&gt;状态选项</div><div class="line"></div><div class="line">//连接设备</div><div class="line">adb connect [IP]</div><div class="line"></div><div class="line">//断开连接</div><div class="line">adb disconnect [IP]</div></pre></td></tr></table></figure>
<ul>
<li>帧率分析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//打开手机设置</div><div class="line">开发者选项-&gt;GPU显示模式分析-&gt;在adb shell dumpsys gfxinfo中</div><div class="line"></div><div class="line">//终端命令</div><div class="line">adb shell dumpsys gfxinfo [package name] &gt; [file path]</div><div class="line"></div><div class="line">//三列数据：</div><div class="line">draw		绘制时间</div><div class="line">process		渲染计算时间</div><div class="line">execute		Cpu等待Gpu处理的时间</div></pre></td></tr></table></figure>
<ul>
<li>dumpsys</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys [value]</div><div class="line"></div><div class="line">value取值：</div><div class="line">Activity</div><div class="line">cpuinfo</div><div class="line">meminfo</div><div class="line">package</div><div class="line">window</div><div class="line">statusbar</div><div class="line">battery/batteryinfo</div><div class="line">alarm</div><div class="line"></div><div class="line">查看帮助：</div><div class="line">1.进入shell模式</div><div class="line">2. dumpsys meminfo -h</div></pre></td></tr></table></figure>
<ul>
<li>logcat</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">adb logcat --help</div><div class="line">1、-s</div><div class="line">adb logcat -s [tag]</div><div class="line">只输出特定的tag日志</div><div class="line"></div><div class="line">2、-f</div><div class="line">adb logcat -f [file path]</div><div class="line">保存日志到手机中，注意是手机</div><div class="line"></div><div class="line">3、-v time</div><div class="line">adb logcat -v time</div><div class="line">输出日志包含具体的时间</div><div class="line"></div><div class="line">4、grep</div><div class="line">过滤指令</div><div class="line"></div><div class="line">5、&gt;</div><div class="line">重定向符，保存日志到PC上，注意是PC</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/07/常用Android工具命令/" data-id="cjawlho090019l3vfg7izmp3l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-管理多个ssh-key" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/07/管理多个ssh-key/" class="article-date">
  <time datetime="2017-11-07T00:37:03.000Z" itemprop="datePublished">2017-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/07/管理多个ssh-key/">管理多个ssh key</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、生成key"><a href="#一、生成key" class="headerlink" title="一、生成key"></a>一、生成key</h2><h3 id="1-命令行执行"><a href="#1-命令行执行" class="headerlink" title="1.命令行执行"></a>1.命令行执行</h3><p><code>ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot;</code> </p>
<h3 id="2-接着提示存储文件名字"><a href="#2-接着提示存储文件名字" class="headerlink" title="2.接着提示存储文件名字"></a>2.接着提示存储文件名字</h3><p>我的命名规则为<code>id_rsa_xxx</code>。<br><img src="/2017/11/07/管理多个ssh-key/ssh-keygen.png" alt="ssh-keygen"></p>
<h3 id="3-之后可以一直回车结束"><a href="#3-之后可以一直回车结束" class="headerlink" title="3.之后可以一直回车结束"></a>3.之后可以一直回车结束</h3><h2 id="二、配置key"><a href="#二、配置key" class="headerlink" title="二、配置key"></a>二、配置key</h2><h3 id="1-命令行执行-1"><a href="#1-命令行执行-1" class="headerlink" title="1.命令行执行"></a>1.命令行执行</h3><p><code>ssh-add ~/.ssh/id_rsa_xxx</code><br><code>id_rsa_xxx</code>是指你在上述步骤生成的密钥文件名。</p>
<h3 id="2-创建config文件"><a href="#2-创建config文件" class="headerlink" title="2.创建config文件"></a>2.创建config文件</h3><ul>
<li>进入.ssh文件夹，创建一个文本文件，命名为config。</li>
<li>每一个key可以按照一下格式加到config文件，#号代表注释。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># github</div><div class="line">Host github</div><div class="line">HostName github.com</div><div class="line">User git</div><div class="line">IdentityFile ~/.ssh/id_rsa_github</div></pre></td></tr></table></figure>
<h2 id="三、测试key"><a href="#三、测试key" class="headerlink" title="三、测试key"></a>三、测试key</h2><h3 id="1-远程仓库配置ssh-key"><a href="#1-远程仓库配置ssh-key" class="headerlink" title="1.远程仓库配置ssh key"></a>1.远程仓库配置ssh key</h3><p>这个请自行搜索。</p>
<h3 id="2-本地测试是否连通"><a href="#2-本地测试是否连通" class="headerlink" title="2.本地测试是否连通"></a>2.本地测试是否连通</h3><ul>
<li>命令行执行<code>ssh -T github</code></li>
<li><code>github</code>是在config文件中定义的Host字段。</li>
<li>测试成功会出现以下提示：<br><img src="/2017/11/07/管理多个ssh-key/ssh -T.png" alt="ssh -T"></li>
</ul>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><ul>
<li>如何在finder中查看.ssh，请搜索mac如何显示隐藏文件。</li>
<li>查看ssh版本<code>ssh -V</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/07/管理多个ssh-key/" data-id="cjawlho0d001gl3vftn7pddh6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Git/" style="font-size: 16.67px;">Git</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/Kotlin/" style="font-size: 13.33px;">Kotlin</a> <a href="/tags/环境配置/" style="font-size: 10px;">环境配置</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/27/CoordinatorLayout的使用/">CoordinatorLayout的使用</a>
          </li>
        
          <li>
            <a href="/2017/11/25/深入理解Android卷一笔记/">深入理解Android卷一笔记</a>
          </li>
        
          <li>
            <a href="/2017/11/23/Effective-Java笔记/">Effective Java笔记</a>
          </li>
        
          <li>
            <a href="/2017/11/19/Glide笔记/">Glide笔记</a>
          </li>
        
          <li>
            <a href="/2017/11/19/android使用kotlin注意事项/">android使用kotlin注意事项</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 JoKing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>