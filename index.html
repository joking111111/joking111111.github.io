<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JoKing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JoKing">
<meta property="og:url" content="https://joking111111.github.io/index.html">
<meta property="og:site_name" content="JoKing">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JoKing">
  
    <link rel="alternate" href="/atom.xml" title="JoKing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoKing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://joking111111.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-CoordinatorLayout的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/27/CoordinatorLayout的使用/" class="article-date">
  <time datetime="2017-11-27T13:45:51.000Z" itemprop="datePublished">2017-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/27/CoordinatorLayout的使用/">CoordinatorLayout的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1-什么是嵌套滚动机制（NestedScrolling）？"><a href="#1-什么是嵌套滚动机制（NestedScrolling）？" class="headerlink" title="1.什么是嵌套滚动机制（NestedScrolling）？"></a>1.什么是嵌套滚动机制（NestedScrolling）？</h3><p>所谓嵌套滚动其实就是界面布局中包含 一个可滚动的列表 和 一个不可滚动的View，这样在滚动列表时，首先将不可滚动View移出屏幕或移进屏幕，待不可滚动View固定时，才会继续滚动滚动列表的内容。</p>
<h3 id="2-为什么要有滑动嵌套机制？"><a href="#2-为什么要有滑动嵌套机制？" class="headerlink" title="2.为什么要有滑动嵌套机制？"></a>2.为什么要有滑动嵌套机制？</h3><p>回想一下android系统事件分发机制，一个down事件到up事件为一个事件流，在这事件流之中一旦某个View拦截（处理）该Touch事件，那么后续这个事件流将统一交由它处理。</p>
<p>有时候我们需要将一个事件流分开成几个事件片给不同的View处理，那么我们需要调配事件分发。滑动嵌套机制应运而生。</p>
<h2 id="二、Android嵌套滚动机制"><a href="#二、Android嵌套滚动机制" class="headerlink" title="二、Android嵌套滚动机制"></a>二、Android嵌套滚动机制</h2><h3 id="1-重要的类"><a href="#1-重要的类" class="headerlink" title="1.重要的类"></a>1.重要的类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NestedScrollingChild接口</div><div class="line">NestedScrollingParent接口</div><div class="line">NestedScrollingChildHelper辅助类</div><div class="line">NestedScrollingParentHelper辅助类</div></pre></td></tr></table></figure>
<h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2.结构图"></a>2.结构图</h3><p><img src="/2017/11/27/CoordinatorLayout的使用/结构图.png" alt="结构图"></p>
<h2 id="三、参考文章"><a href="#三、参考文章" class="headerlink" title="三、参考文章"></a>三、参考文章</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/GDC3YLLPYsoalr8sg38dmg" target="_blank" rel="external">CoordinatorLayout和Behavior详解</a></li>
<li><a href="https://mp.weixin.qq.com/s/-ldKAMGChfbvk8E8nzvuNw" target="_blank" rel="external">CoordinatorLayout高级用法-自定义Behavior</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/27/CoordinatorLayout的使用/" data-id="cjal6y3l30005agvf8mbe4o4l" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Android卷一笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/25/深入理解Android卷一笔记/" class="article-date">
  <time datetime="2017-11-25T14:52:35.000Z" itemprop="datePublished">2017-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/25/深入理解Android卷一笔记/">深入理解Android卷一笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、JNI调用流程分析"><a href="#一、JNI调用流程分析" class="headerlink" title="一、JNI调用流程分析"></a>一、JNI调用流程分析</h2><h3 id="1-Java层"><a href="#1-Java层" class="headerlink" title="1.Java层"></a>1.Java层</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MediaScanner &#123;</div><div class="line">	static &#123;</div><div class="line">		System.loadLibrary(&quot;media_jni&quot;);</div><div class="line">		native_init();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private static native void native_init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>加载对应的JNI库。</li>
<li>声明native函数。</li>
</ul>
<h3 id="2-JNI层"><a href="#2-JNI层" class="headerlink" title="2.JNI层"></a>2.JNI层</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//cpp</div><div class="line">static void android_media_MediaScanner_native_init(JNIEnv *env) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么Java层调用native函数，系统是如何找到JNI层的对应函数的呢？</p>
<h4 id="一、静态注册"><a href="#一、静态注册" class="headerlink" title="一、静态注册"></a>一、静态注册</h4><p>流程：</p>
<ul>
<li>编写java层native函数声明，并javac编译为class文件。</li>
<li>使用<code>javah -o output packagename.classname</code>生成.h头文件。</li>
<li>JNI层cpp或者c文件实现该头文件。</li>
</ul>
<p>当Java层第一次调用该native方法时，jvm会从对应库找对应的头文件。如果找到，保存这个函数指针供下次调用；如果没找到就抛异常。</p>
<p>弊端：</p>
<ul>
<li>修改Java层的native方式后需要重新生成头文件，因为函数签名可能改变了。</li>
<li>初次调用native函数才会去建立关联，有懒加载特性，有利有弊。</li>
</ul>
<h4 id="二、动态注册"><a href="#二、动态注册" class="headerlink" title="二、动态注册"></a>二、动态注册</h4><p>JNI中有一个数据结构专门来记录这种一一对应关系的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">	const char* signature;</div><div class="line">	void* fnPtr;</div><div class="line">&#125; JNINativeMethod;</div></pre></td></tr></table></figure>
<p>AndroidRunTime.cpp提供了registerNativeMethods方法来注册；其中又通过JNIHelp.c的jniRegisterNativeMethods。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jclass clazz = (*env) -&gt; FindClass(env, className);</div><div class="line">(*env) -&gt; RegisterNatives(env, clazz, gMethods, numMethods);</div></pre></td></tr></table></figure>
<ul>
<li>1.当Java层通过System.loadLibrary加载so库时，会先找是否有JNI_OnLoad函数，如果有就调用它；</li>
<li>2.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/25/深入理解Android卷一笔记/" data-id="cjal6y3ls001eagvf0pz11axz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-Java笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Effective-Java笔记/" class="article-date">
  <time datetime="2017-11-23T14:42:17.000Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/23/Effective-Java笔记/">Effective Java笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、创建和销毁对象"><a href="#一、创建和销毁对象" class="headerlink" title="一、创建和销毁对象"></a>一、创建和销毁对象</h2><h3 id="1-静态工厂方法和公有构造函数"><a href="#1-静态工厂方法和公有构造函数" class="headerlink" title="1.静态工厂方法和公有构造函数"></a>1.静态工厂方法和公有构造函数</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static Boolean valueOf(boolean b) &#123;</div><div class="line">	return b ? Boolean.TRUE : Boolean.FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>静态工厂方法名相对构造函数，方便指示使用者选择合适的方法。</li>
<li>静态工厂方法可以控制不创建新对象，而是重复使用一些对象。如示例代码所示。</li>
<li>静态工厂方法可返回返回类型的子类对象，设计模式中的工厂模式。</li>
</ul>
<p>缺点：</p>
<ul>
<li>静态工厂方法一般会把构造函数非公有，导致类不能被继承。但是这样鼓励我们使用组合而非继承。</li>
</ul>
<p>总结：</p>
<ul>
<li>如果需要重用对象（单例），请使用静态工厂方法。</li>
<li>如果需要提供不同的具体实现（子类），或者说面向接口编程，请使用静态工厂方法。</li>
</ul>
<h3 id="2-多个构造函数与Builder（构建者）"><a href="#2-多个构造函数与Builder（构建者）" class="headerlink" title="2.多个构造函数与Builder（构建者）"></a>2.多个构造函数与Builder（构建者）</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public MyView(Context context) &#123;</div><div class="line">       this(context, 100, 100);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyView(Context context, int width, int height) &#123;</div><div class="line">       this(context, width, height);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyView(Context context, int width, int height, int margin) &#123;</div><div class="line">		...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像这种参数比较多，并且有可选参数时，建议使用Builder模式。<br>另外，Builder不建议使用Java Bean的getter、setter形式，建议使用链式调用写法，代码更简洁。</p>
<p>优点：</p>
<ul>
<li>将传入的参数处理职责分离出去，类专注于功能，Builder专注于构建类参数，这样代码可读性跟拓展性增强。</li>
</ul>
<h3 id="3-避免创建不必要的对象"><a href="#3-避免创建不必要的对象" class="headerlink" title="3.避免创建不必要的对象"></a>3.避免创建不必要的对象</h3><p>比如SimpleDateFormat对象。</p>
<h3 id="4-清除过期的对象引用"><a href="#4-清除过期的对象引用" class="headerlink" title="4.清除过期的对象引用"></a>4.清除过期的对象引用</h3><ul>
<li>适当的时候将引用置为null。</li>
<li>使用WeakReference。</li>
</ul>
<h3 id="5-避免使用finalize方法"><a href="#5-避免使用finalize方法" class="headerlink" title="5.避免使用finalize方法"></a>5.避免使用finalize方法</h3><p>原因：</p>
<ul>
<li>jvm不保证对象的finalize方法及时执行。</li>
<li>jvm不保证对象的finalize方法一定执行。</li>
</ul>
<p>建议：</p>
<ul>
<li>在适当的时机，如try-catch中finally代码块调用close、recycle等方法。</li>
</ul>
<h2 id="二、方法的实现"><a href="#二、方法的实现" class="headerlink" title="二、方法的实现"></a>二、方法的实现</h2><h3 id="1-重写equals"><a href="#1-重写equals" class="headerlink" title="1.重写equals"></a>1.重写equals</h3><p>性质：</p>
<ul>
<li>自反性（reflexive） x.equals(x) = true</li>
<li>对称性（symmetric） x.equals(y) &lt;=&gt; y.equals(x)</li>
<li>传递性（transitive） x.equals(y) = y.equals(z) 那么 x.equals(z)结果应为一样</li>
<li>一致性（consistent）x,y不变时，x.equals(y)也不变</li>
<li>非null的x，x.equals(null) = false</li>
</ul>
<p>由于参数固定为Object类型（否则就是方法重载了），有必要做类型检查（instanceOf）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean equals(Object o) &#123;</div><div class="line">       return super.equals(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-重写hashCode"><a href="#2-重写hashCode" class="headerlink" title="2.重写hashCode"></a>2.重写hashCode</h3><p>重写了equals方法后，最好也重写hashCode方法。</p>
<p>原因：</p>
<ul>
<li>两个对象equals方法返回true，不代表两个对象的hashCode返回值相等。</li>
<li>默认hashCode本质上是这个对象的散列值，是以整个对象所有对象生成的，而我们重写equals方法可能只用到对象的关键成员，并不是全体成员。</li>
</ul>
<p>常用的类比如HashMap，我们使用自定义的类作为key时，HashMap会调用key的hashCode方法作为判定key相等的依据之一，并不是重写了equals方法就万事大吉了。</p>
<h3 id="3-重写toString"><a href="#3-重写toString" class="headerlink" title="3.重写toString"></a>3.重写toString</h3><p>可以准备好一份模版或者使用脚本，生成toString函数。<br>比如可以利用toString将Java Bean转换为json字符串。</p>
<h2 id="三、类和接口"><a href="#三、类和接口" class="headerlink" title="三、类和接口"></a>三、类和接口</h2><h3 id="1-组合优于继承"><a href="#1-组合优于继承" class="headerlink" title="1.组合优于继承"></a>1.组合优于继承</h3><p>对于接口的实现和继承不适用这条。</p>
<p>父类有可能因为版本迭代而修改某些方法，这样子类很可能也要做出改变，但是我们可能对具体实现不敏感，只是想增加额外方法。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 接口定义</div><div class="line">*/</div><div class="line">public interface PriceCalculator &#123;</div><div class="line">	float getPrice(int sum);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 包装类</div><div class="line">*/</div><div class="line">public PriceCalculatorWrapper implements PriceCalculator &#123;</div><div class="line">	private PriceCalculator mCalculator;</div><div class="line">	</div><div class="line">	//唯一构造函数</div><div class="line">	public PriceCalculatorWrapper(PriceCalculator calculator) &#123;</div><div class="line">		this.mCalculator = calculator;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@override</div><div class="line">	public float getPrice(int sum) &#123;</div><div class="line">		return mCalculator.getPrice(sum);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 具体实现类</div><div class="line">*/</div><div class="line">public ShopPriceCalculator implements PriceCalculator &#123;</div><div class="line">	@override</div><div class="line">	public float getPrice(int sum) &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以跟设计模式中的策略模式关联起来。</p>
<h3 id="2-接口优于抽象类"><a href="#2-接口优于抽象类" class="headerlink" title="2.接口优于抽象类"></a>2.接口优于抽象类</h3><ul>
<li>一个类能实现多个接口，只能继承一个类。</li>
<li>面向接口编程，外界知道得越少越好。</li>
<li>接口定义了一类方法的集合，做一件事可能有几个步骤，但是是通过一个接口完成的。</li>
</ul>
<h3 id="3-接口最好只定义方法"><a href="#3-接口最好只定义方法" class="headerlink" title="3.接口最好只定义方法"></a>3.接口最好只定义方法</h3><p>接口虽然可以有静态常量成员变量，但是并不是每个接口的实现类都会用到这些变量。虽然这并不影响运行效率，但是从代码可读性而言，在接口定义静态常量成员变量不是明智之举。</p>
<h3 id="4-使用函数对象实现策略模式"><a href="#4-使用函数对象实现策略模式" class="headerlink" title="4.使用函数对象实现策略模式"></a>4.使用函数对象实现策略模式</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">interface Comparator&lt;T&gt; &#123;</div><div class="line">	int compare(T t1, T t2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class StringLengthComparator implements Comparator&lt;String&gt; &#123;</div><div class="line">	@override</div><div class="line">	public int compare(String s1, String s2) &#123;</div><div class="line">		return s1.length() - s2.length();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//每一次排序均要创建一个比较函数对象</div><div class="line">Array.sort(stringArray, new StringLengthComparator());</div></pre></td></tr></table></figure>
<p>C++支持函数指针，即把一个函数体用指针作为参数传入别的作用域。这样可以达到面向接口编程的效果，不关注方法的具体实现。而java中，最相似的案例就是回调监听的实现了，只不过java没有指针，而是通过一个实现了监听接口的对象来传入别的作用域。</p>
<p>由于策略模式的方法具体实现是无状态的（上一次调用与下一次调用无关），所以可以考虑将函数对象做成单例。</p>
<p>建议：</p>
<ul>
<li>如果需要频繁使用该函数，那么最好做成一个单例，而不是每一次都创建新对象。</li>
<li>如果使用次数不多，做成单例会导致函数对象生命周期过长，对于内存敏感的程序要慎重，虽然这个单例占用内存可能不多。</li>
</ul>
<h3 id="5-慎用非静态内部类"><a href="#5-慎用非静态内部类" class="headerlink" title="5.慎用非静态内部类"></a>5.慎用非静态内部类</h3><p>匿名内部类也属于非静态内部类。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivty extends ... &#123;</div><div class="line">	public void work() &#123;</div><div class="line">		new Thread() &#123;</div><div class="line">			Toast.makeText(MainActivity.this, &quot;hello world&quot; ,Toast.LENGTH_SHORT);</div><div class="line">			//do something</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在work函数里面，创建了一个匿名内部类，它持有了外部类的强引用（MainActivity.this）。如果内部类的生命周期比外部类长的话，就会发生内存泄漏。</p>
<p>不仅是内存泄漏，由于内部类有外部类的强引用，也会占用一定内存空间。比如HashMap中的Entry如果不是静态内部类，那么每个Entry都会拥有HashMap的强引用，一旦节点数量多了，也会影响性能。</p>
<p>建议：</p>
<ul>
<li>如果不需要外部类的引用（调用方法），请加上static关键字修饰内部类。</li>
<li>如果需要使用非静态内部类，请谨慎管理非静态内部类对象的生命周期。</li>
</ul>
<h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="1-不要使用原生态类型"><a href="#1-不要使用原生态类型" class="headerlink" title="1.不要使用原生态类型"></a>1.不要使用原生态类型</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//原生态类型</div><div class="line">List list = new ArrayList();</div><div class="line"></div><div class="line">//非原生态类型</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">--------------------------------------------------------------------</div><div class="line"></div><div class="line">//错误代码</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">unsafeAdd(list, new Integer(1));</div><div class="line">//crash</div><div class="line">list.get(0);</div><div class="line"></div><div class="line">--------------------------------------------------------------------</div><div class="line">public static void unsafeAdd(List list, Object o)&#123;</div><div class="line">	list.add(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>unsafeAdd方法参数list使用了原生态类型，并没有对插入元素做类型检查。所以在编译期不会报错。</li>
<li>等到调用了get方法时，程序尝试将Integer强转为String，抛出异常。</li>
</ul>
<p>注意！有两种特殊情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//1.获取class类</div><div class="line">List.class,String[].class,int.class 合法</div><div class="line">List&lt;String&gt;,List&lt;?&gt;.class 不合法</div><div class="line"></div><div class="line">//2.类型判定</div><div class="line">if (o instanceOf Set) &#123;</div><div class="line">	Set&lt;?&gt; set = (Set&lt;?&gt;) o;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：<br>我们应该使用带泛型参数的类，让编译器帮助我们暴露程序的问题，而不是等到程序运行异常才暴露问题。</p>
<h3 id="2-泛型列表优于泛型数组"><a href="#2-泛型列表优于泛型数组" class="headerlink" title="2.泛型列表优于泛型数组"></a>2.泛型列表优于泛型数组</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//运行时报错</div><div class="line">Object[] objects = new Long[1];</div><div class="line">objects[0] = &quot;hello world&quot;;</div><div class="line"></div><div class="line">//编译不通过</div><div class="line">List&lt;Object&gt; list = new ArrayList&lt;Long&gt;();</div><div class="line">list.add(&quot;hello world&quot;);</div></pre></td></tr></table></figure>
<p>原因：</p>
<ul>
<li>Object[]是Long[]的父类，因此分配内存给objects时不会抛异常。</li>
<li>List<object>并不是ArrayList<long>的父类，也不是List<long>的父类，所以编译不通过。</long></long></object></li>
<li>Java泛型使用的是类型擦除机制实现泛型的，运行时把具体类型替换掉。编译期在编译时会做类型检查，这也是使用非原生态类型的好处。</li>
</ul>
<h2 id="五、枚举和注解"><a href="#五、枚举和注解" class="headerlink" title="五、枚举和注解"></a>五、枚举和注解</h2><h3 id="1-用enum代替int常量"><a href="#1-用enum代替int常量" class="headerlink" title="1.用enum代替int常量"></a>1.用enum代替int常量</h3><p>Java枚举类型基本想法：通过public static final为每个枚举常量导出实例的类。</p>
<ul>
<li>枚举没有公有构造函数，所以程序员无法手动创建枚举实例。</li>
<li>枚举是线程安全的（final），也是防序列化反序列化的，很适合做单例。</li>
<li>枚举常量是一个个对象，功能上肯定比一个int常量要强多了，相对的开销也大了。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public enum Sample &#123;</div><div class="line">	SOLO(1), DUET(2), TRIO(3);</div><div class="line">	</div><div class="line">	private final int order;</div><div class="line">	Sample(int order) &#123;</div><div class="line">		this.order = order;</div><div class="line">	&#125;</div><div class="line">	public int getOrder() &#123;</div><div class="line">		return order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要使用默认顺序和ordinal()函数，而是使用一个成员变量记录序号。因为这样便于维护和检查。</p>
<h3 id="2-坚持使用override注解"><a href="#2-坚持使用override注解" class="headerlink" title="2.坚持使用override注解"></a>2.坚持使用override注解</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	private int order;</div><div class="line">	public boolean equals (Test t) &#123;</div><div class="line">		return this.order == t.order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>equals没有使用override注解，导致编译期编译时没有“检查”。事实上，这个equals方法看似是重写，实际上是重载。因为equals方法原型是<code>public boolean equals(Object o)</code>。</p>
<h3 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3.常用注解"></a>3.常用注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@callSuper //声明子类若重写该方法，必须调用父类方法</div></pre></td></tr></table></figure>
<h2 id="六、函数方法"><a href="#六、函数方法" class="headerlink" title="六、函数方法"></a>六、函数方法</h2><h3 id="1-必要时进行保护性拷贝"><a href="#1-必要时进行保护性拷贝" class="headerlink" title="1.必要时进行保护性拷贝"></a>1.必要时进行保护性拷贝</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Adapter &#123;</div><div class="line">	private List&lt;String&gt; mList;</div><div class="line">	public Adapter(List&lt;String&gt; list) &#123;</div><div class="line">		mList = list;//没有保护性拷贝</div><div class="line">		mList = new ArrayList(list);//进行保护性拷贝</div><div class="line">		...</div><div class="line">		//检查参数有效性</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一条主要按业务逻辑分的，如果想共用同一个参数对象，那么保存它的引用就好，否则我们应该新创建一个对象对参数对象进行拷贝。</p>
<p>保护性拷贝场景：</p>
<ul>
<li>不希望参数对象在类外部变化时能影响类时。</li>
<li>对并发场景有要求。</li>
</ul>
<h3 id="2-检查参数有效性"><a href="#2-检查参数有效性" class="headerlink" title="2.检查参数有效性"></a>2.检查参数有效性</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@override</div><div class="line">public boolean equals(Object o) &#123;</div><div class="line">	if(o instanceOf String) &#123;</div><div class="line">		String s = (String) o;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查参数有效性一般在保护性拷贝之后。方法调用前检查参数合法性，减少调试的复杂性。</p>
<h3 id="3-谨慎增加快捷方法"><a href="#3-谨慎增加快捷方法" class="headerlink" title="3.谨慎增加快捷方法"></a>3.谨慎增加快捷方法</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void showWindow(int width, int height, long time) &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">//快捷方法，宽高默认100</div><div class="line">public void showWindow(long time) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除非快捷方法经常被调用，否则最好不要写快捷方法。因为增加快捷方法会使类的方法数上升，对于用户的理解难度相对增加；对于维护者，增加了维护默认参数和文档的职责。</p>
<h3 id="4-谨慎使用重载"><a href="#4-谨慎使用重载" class="headerlink" title="4.谨慎使用重载"></a>4.谨慎使用重载</h3><p>这里需要强调重载和重写的运行时机区别：</p>
<ul>
<li>重载方法运行时机是在编译期确定好的，一个参数对象编译期是什么类型，决定了它会走哪个重载方法，并不会它运行时是子类对象而发生改变。</li>
<li>重写方法运行时机是在运行时才确定的，是根据对象的实际类型决定走哪个类的重写方法，不受编译时类型影响。</li>
</ul>
<h3 id="5-谨慎使用可变参数"><a href="#5-谨慎使用可变参数" class="headerlink" title="5.谨慎使用可变参数"></a>5.谨慎使用可变参数</h3><p>弊端：</p>
<ul>
<li>方法调用前得检查参数有效性稍麻烦。</li>
<li>可变参数方法的每次调用都会导致进行一次数组分配和初始化。</li>
</ul>
<p>建议：</p>
<ul>
<li>根据调用频率，给频率高的方法提供单独方法，对于频率低的可以使用可变参数方法。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void foo() &#123; &#125;</div><div class="line">public void foo(int a1) &#123; &#125;</div><div class="line">public void foo(int a1, int a2) &#123; &#125;</div><div class="line">public void foo(int a1, int a2, int a3) &#123; &#125;</div><div class="line">public void foo(int a1, int a2, int a3, int... rest) &#123; &#125;</div></pre></td></tr></table></figure>
<h3 id="6-返回长度为零的数组或集合，而不是null"><a href="#6-返回长度为零的数组或集合，而不是null" class="headerlink" title="6.返回长度为零的数组或集合，而不是null"></a>6.返回长度为零的数组或集合，而不是null</h3><p>原因：</p>
<ul>
<li>返回null调用者需要对null作额外处理。当然调用者也需要对零长度作处理。</li>
<li>零长度的数组或集合创建开销并不大。</li>
<li>零长度的数组属于不可变的（final），可以共享。</li>
</ul>
<h2 id="七、通用程序设计"><a href="#七、通用程序设计" class="headerlink" title="七、通用程序设计"></a>七、通用程序设计</h2><h3 id="1-尽量使用for-each而不是for循环和使用Iterator"><a href="#1-尽量使用for-each而不是for循环和使用Iterator" class="headerlink" title="1.尽量使用for-each而不是for循环和使用Iterator"></a>1.尽量使用for-each而不是for循环和使用Iterator</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//for-each</div><div class="line">for(String s : list) &#123;</div><div class="line">	doSomething(s);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//for循环</div><div class="line">for(int i = 0;i &lt; a.length; i++) &#123;</div><div class="line">	doSomething(a[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Iterator</div><div class="line">for(Iterator&lt;String&gt; i = list.iterator(); i.hasNext(); ) &#123;</div><div class="line">	doSomething(i.next());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>代码简洁。</li>
<li>性能较好，只计算一次size。</li>
</ul>
<h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/23/Effective-Java笔记/" data-id="cjal6y3kz0003agvfa89faatf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Glide笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/Glide笔记/" class="article-date">
  <time datetime="2017-11-19T06:23:15.000Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/Glide笔记/">Glide笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-基本组件"><a href="#一-基本组件" class="headerlink" title="一.基本组件"></a>一.基本组件</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><p>以下均基于Glide4.x版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//加载图片</div><div class="line">Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options)</div><div class="line">.into(imageView);</div><div class="line"></div><div class="line">//取消加载</div><div class="line">Glide.with(getContext())</div><div class="line">.clear(imageView);</div></pre></td></tr></table></figure>
<h3 id="2-RequestOptions"><a href="#2-RequestOptions" class="headerlink" title="2.RequestOptions"></a>2.RequestOptions</h3><p>Glide的常用选项</p>
<ul>
<li>裁剪样式circleCrop、circleCrop等。</li>
<li>加载中占位图placeholder</li>
<li>加载失败图error</li>
<li>…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RequestOptions centerCropOptions = new RequestOptions()</div><div class="line">            .centerCrop()</div><div class="line">            .placeholder(R.drawable.img_loading)</div><div class="line">            .error(R.drawable.img_failed);</div></pre></td></tr></table></figure>
<h3 id="3-RequestBuilder"><a href="#3-RequestBuilder" class="headerlink" title="3.RequestBuilder"></a>3.RequestBuilder</h3><p>可以理解为一个个的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RequestBuilder builder = Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options);</div></pre></td></tr></table></figure>
<p>当调用RequestBuilder.into(target)时开始加载。这个方法的返回值类型不再是RequestBuilder了。</p>
<h2 id="二、常用操作"><a href="#二、常用操作" class="headerlink" title="二、常用操作"></a>二、常用操作</h2><h3 id="1-加载失败回调监听"><a href="#1-加载失败回调监听" class="headerlink" title="1.加载失败回调监听"></a>1.加载失败回调监听</h3><p>RequestBuilder.listen(RequestListener)方法监听load成功还是失败。</p>
<ul>
<li>注意这里不能在监听里对同一个target（imageView）发起加载请求，因为当前请求尚未结束，会抛出异常。</li>
<li>所以无法使用这个监听实现加载失败时加载备用url的需求。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options)</div><div class="line">.listener(new RequestListener() &#123;</div><div class="line">	@Override</div><div class="line">	public boolean onLoadFailed(@Nullable GlideException e, Object model, Target target, boolean isFirstResource) &#123;</div><div class="line">		//false：事件继续往下传递</div><div class="line">		//true：事件不再往下传递</div><div class="line">   		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public boolean onResourceReady(Object resource, Object model, Target target, DataSource dataSource, boolean isFirstResource) &#123;</div><div class="line">		//false：事件继续往下传递</div><div class="line">		//true：事件不再往下传递</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">.into(imageView);</div></pre></td></tr></table></figure>
<h3 id="2-请求失败后启用备用请求"><a href="#2-请求失败后启用备用请求" class="headerlink" title="2.请求失败后启用备用请求"></a>2.请求失败后启用备用请求</h3><p>RequestBuilder.error(RequestBuilder)方法可以在这个request失败后启用备用的request。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">RequestBuilder builder1 = Glide.with(getContext())</div><div class="line">.load(url1)</div><div class="line">.apply(options);</div><div class="line"></div><div class="line">RequestBuilder builder2 = Glide.with(getContext())</div><div class="line">.load(url2)</div><div class="line">.apply(options)</div><div class="line">.error(builder1);</div><div class="line"></div><div class="line">builder2.into(imageView);</div></pre></td></tr></table></figure>
<p>这段代码意义为当url2加载失败后，会启用builder1这个请求，加载url1。这样我们就可以实现多级url加载了。</p>
<p>以下为多级加载url方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void loadUrls(String[] urls, RequestOptions options, ImageView imageView) &#123;</div><div class="line">        if (urls == null || urls.length == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        RequestBuilder&lt;Drawable&gt; frontBuilder = Glide.with(getContext()).load(urls[0]).apply(options);</div><div class="line">        RequestBuilder&lt;Drawable&gt; prevBuilder = frontBuilder;</div><div class="line">        </div><div class="line">        for (int i = 1; i &lt; urls.length; i++) &#123;</div><div class="line">            RequestBuilder&lt;Drawable&gt; nextBuilder = Glide.with(getContext()).load(urls[i]).apply(options);</div><div class="line">            prevBuilder.error(nextBuilder);</div><div class="line">            prevBuilder = nextBuilder;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        frontBuilder.into(imageView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/19/Glide笔记/" data-id="cjal6y3l50008agvfh066gs6q" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android使用kotlin注意事项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/android使用kotlin注意事项/" class="article-date">
  <time datetime="2017-11-19T06:23:03.000Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/android使用kotlin注意事项/">android使用kotlin注意事项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、注意参数可空"><a href="#一、注意参数可空" class="headerlink" title="一、注意参数可空"></a>一、注意参数可空</h2><p>现在第三方库基本都用java写，使用kotlin调用三方库时，最常见的场景就是实现回调接口。实现回调接口的时候，注意接口方法参数如果可空一定要加上”?”修饰，否则崩溃时很难从日志发现问题所在。</p>
<ul>
<li>基本数据类型没必要加”?”，只有对象才需要加。</li>
<li>使用kotlin设计接口时也要注意这一点。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/19/android使用kotlin注意事项/" data-id="cjal6y3la000hagvfg0kuh1f1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Kotlin/">Kotlin</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-搭建基于hexo的博客以及如何迁移" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/09/搭建基于hexo的博客以及如何迁移/" class="article-date">
  <time datetime="2017-11-09T13:22:17.000Z" itemprop="datePublished">2017-11-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/09/搭建基于hexo的博客以及如何迁移/">搭建基于hexo的博客以及如何迁移</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、搭建环境"><a href="#一、搭建环境" class="headerlink" title="一、搭建环境"></a>一、搭建环境</h2><h3 id="1-安装git"><a href="#1-安装git" class="headerlink" title="1.安装git"></a>1.安装git</h3><h3 id="2-安装Node-js"><a href="#2-安装Node-js" class="headerlink" title="2.安装Node.js"></a>2.安装Node.js</h3><h3 id="3-检查版本"><a href="#3-检查版本" class="headerlink" title="3.检查版本"></a>3.检查版本</h3><p>以上安装可以通过Homebrew。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">node -v</div><div class="line">npm -v</div><div class="line">git --version</div></pre></td></tr></table></figure>
<h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h3><p>终端所在位置就是安装位置。<br><code>npm install -g hexo-cli</code></p>
<h3 id="5-初始化本地博客"><a href="#5-初始化本地博客" class="headerlink" title="5.初始化本地博客"></a>5.初始化本地博客</h3><p>新建一个合适的文件夹如hexo。注意这个文件夹必须为空，否则提示错误。<br><code>hexo init hexo</code><br>期间请按照终端的提示操作就好了。</p>
<h2 id="二、hexo的使用"><a href="#二、hexo的使用" class="headerlink" title="二、hexo的使用"></a>二、hexo的使用</h2><h3 id="1-主要文件和目录"><a href="#1-主要文件和目录" class="headerlink" title="1.主要文件和目录"></a>1.主要文件和目录</h3><ul>
<li><code>_config.yml</code>这个文件是这个博客的配置文件。<br>具体看<a href="https://hexo.io/zh-cn/docs/configuration.html" target="_blank" rel="external">官方文档</a>。</li>
<li>source文件夹<br>这个文件夹存放你写的md文件。我一般在github创建一个仓库，利用git进行管理。当然你的博客原文件将被看到，有被抄袭的风险。</li>
</ul>
<h3 id="2-使用命令"><a href="#2-使用命令" class="headerlink" title="2.使用命令"></a>2.使用命令</h3><ul>
<li><code>hexo n &quot;hello world&quot;</code>创建名为hello world的博客。</li>
<li><code>hexo g</code>hexo生成html等文件。</li>
<li><code>hexo s</code>hexo使用node.js运行本地服务器进行预览。<br>在命令行会看到预览地址，用浏览器打开就是了。命令行control+c退出本地服务器。</li>
</ul>
<h2 id="三、迁移博客"><a href="#三、迁移博客" class="headerlink" title="三、迁移博客"></a>三、迁移博客</h2><p><a href="https://www.zhihu.com/question/21193762/answer/103097754" target="_blank" rel="external">使用hexo，如果换了电脑怎么更新博客？ - skycrown的回答</a></p>
<h2 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h2><ul>
<li>《Android群英传 神兵利器》徐宜生著</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/09/搭建基于hexo的博客以及如何迁移/" data-id="cjal6y3lr001cagvfk2v0gv36" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mac下配置zsh" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/08/mac下配置zsh/" class="article-date">
  <time datetime="2017-11-08T01:09:06.000Z" itemprop="datePublished">2017-11-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/08/mac下配置zsh/">mac下配置zsh</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h2><p>以下安装请自行搜索。</p>
<ul>
<li>安装homebrew。</li>
<li>安装homebrew cask。</li>
</ul>
<h2 id="2-配置过程"><a href="#2-配置过程" class="headerlink" title="2.配置过程"></a>2.配置过程</h2><ul>
<li><p>安装brew上的zsh <code>brew install zsh</code></p>
</li>
<li><p>安装iterm2（可选，只是换更好用的终端） <code>brew cask install iterm2</code></p>
</li>
<li><p>切换到zsh<br><code>chsh -s /bin/zsh</code><br>如果要切换回来，执行<br><code>chsh -s /bin/bash</code><br>查看当前使用哪种shell<br><code>echo $SHELL</code></p>
</li>
</ul>
<h2 id="3-进阶配置"><a href="#3-进阶配置" class="headerlink" title="3.进阶配置"></a>3.进阶配置</h2><ul>
<li><p>下载oh-my-zsh，不需要设置哪个目录，新开一个终端就可以了。 <code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</code></p>
</li>
<li><p>拷贝出oh-my-zsh中的文件作为自己的配置文件 <code>cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</code></p>
</li>
<li><p>在.zshrc文件中，追加<code>source .bash_profile</code>保留以前配置的环境变量。</p>
</li>
<li><p>zsh还有许多拓展插件，详细可以查看<br><a href="https://github.com/zsh-users" target="_blank" rel="external">https://github.com/zsh-users</a>。</p>
</li>
</ul>
<h2 id="4-可能遇到的问题"><a href="#4-可能遇到的问题" class="headerlink" title="4.可能遇到的问题"></a>4.可能遇到的问题</h2><ul>
<li>没有.bash_profile文件，请自行创建一个。</li>
<li>没有.zshrc文件，请执行拷贝配置文件的命令。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/08/mac下配置zsh/" data-id="cjal6y3ln0015agvfi9hbkw7i" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-常用Android工具命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/07/常用Android工具命令/" class="article-date">
  <time datetime="2017-11-07T01:02:57.000Z" itemprop="datePublished">2017-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/07/常用Android工具命令/">常用Android工具命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、Gradle"><a href="#一、Gradle" class="headerlink" title="一、Gradle"></a>一、Gradle</h2><ul>
<li>gradlew是gradle wrapper中的可执行命令。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">1、查看gradle版本</div><div class="line">./gradlew -v</div><div class="line">  </div><div class="line">2、清空build文件夹下所有东西</div><div class="line">./gradlew clean</div><div class="line"></div><div class="line">3、检查依赖并编译打包。一般按照build type打出所有包</div><div class="line">./gradlew build</div><div class="line"></div><div class="line">4、打出Debug版本apk，文件在build/output/apk目录下,对应地有assmbleRelease命令</div><div class="line">./gradlew assembleDebug</div><div class="line"></div><div class="line">5、相比上一个命令，清理了编译缓存</div><div class="line">./gradlew clean assembleDebug</div><div class="line"></div><div class="line">6、Release模式打包并安装</div><div class="line">./gradlew installRelease</div><div class="line"></div><div class="line">7、卸载Release模式包</div><div class="line">./gradlew uninstallRelease</div></pre></td></tr></table></figure>
<h2 id="二、aapt"><a href="#二、aapt" class="headerlink" title="二、aapt"></a>二、aapt</h2><p>aapt全名android asset packaging tool。</p>
<ul>
<li>列举apk里有什么文件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">list可以简写为l</div><div class="line">aapt list [apk path]		在命令行输出</div><div class="line">appt list [apk path] &gt; [file path]		输出到文件</div></pre></td></tr></table></figure>
<ul>
<li>查看指定文件信息。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dump可以简写为d</div><div class="line">aapt dump [value] [apk path]</div><div class="line"></div><div class="line">value的取值有：</div><div class="line">badging</div><div class="line">permissions</div><div class="line">resources</div><div class="line">configurations</div><div class="line">xmltree</div><div class="line">xmlstrings</div><div class="line"></div><div class="line">xmltree,xmlstrings这两个value在命令后面需要加文件相对路径：</div><div class="line">aapt dump xmltree [apk path] [file path]</div></pre></td></tr></table></figure>
<ul>
<li>修改apk包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aapt package		打成压缩包</div><div class="line">aapt remove		从压缩包中删除</div><div class="line">aapt add		向压缩包添加指定文件</div></pre></td></tr></table></figure>
<ul>
<li>显示aapt工具的版本<code>aapt version</code></li>
</ul>
<h2 id="三、adb"><a href="#三、adb" class="headerlink" title="三、adb"></a>三、adb</h2><p>adb全名android debug bridge。<br>在不知道某个指令怎么使用时，如adb shell pm，在指令后加上help，这样会输出提示信息。</p>
<ul>
<li>常用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//进入shell模式</div><div class="line">adb shell</div><div class="line"></div><div class="line">//退出shell模式</div><div class="line">exit</div><div class="line"></div><div class="line">//查看连接上的devices</div><div class="line">adb devices</div><div class="line"></div><div class="line">//安装apk</div><div class="line">adb install -r &lt;path&gt;</div><div class="line"></div><div class="line">//从设备拉取文件</div><div class="line">adb pull &lt;remote&gt; &lt;local&gt;从设备拉取文件</div><div class="line"></div><div class="line">//推送文件到设备</div><div class="line">adb push &lt;local&gt; &lt;remote&gt;</div></pre></td></tr></table></figure>
<ul>
<li>无线调试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//获取设备IP，确保在同一局域网中</div><div class="line">设置-&gt;关于-&gt;状态选项</div><div class="line"></div><div class="line">//连接设备</div><div class="line">adb connect [IP]</div><div class="line"></div><div class="line">//断开连接</div><div class="line">adb disconnect [IP]</div></pre></td></tr></table></figure>
<ul>
<li>帧率分析</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//打开手机设置</div><div class="line">开发者选项-&gt;GPU显示模式分析-&gt;在adb shell dumpsys gfxinfo中</div><div class="line"></div><div class="line">//终端命令</div><div class="line">adb shell dumpsys gfxinfo [package name] &gt; [file path]</div><div class="line"></div><div class="line">//三列数据：</div><div class="line">draw		绘制时间</div><div class="line">process		渲染计算时间</div><div class="line">execute		Cpu等待Gpu处理的时间</div></pre></td></tr></table></figure>
<ul>
<li>dumpsys</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">adb shell dumpsys [value]</div><div class="line"></div><div class="line">value取值：</div><div class="line">Activity</div><div class="line">cpuinfo</div><div class="line">meminfo</div><div class="line">package</div><div class="line">window</div><div class="line">statusbar</div><div class="line">battery/batteryinfo</div><div class="line">alarm</div><div class="line"></div><div class="line">查看帮助：</div><div class="line">1.进入shell模式</div><div class="line">2. dumpsys meminfo -h</div></pre></td></tr></table></figure>
<ul>
<li>logcat</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">adb logcat --help</div><div class="line">1、-s</div><div class="line">adb logcat -s [tag]</div><div class="line">只输出特定的tag日志</div><div class="line"></div><div class="line">2、-f</div><div class="line">adb logcat -f [file path]</div><div class="line">保存日志到手机中，注意是手机</div><div class="line"></div><div class="line">3、-v time</div><div class="line">adb logcat -v time</div><div class="line">输出日志包含具体的时间</div><div class="line"></div><div class="line">4、grep</div><div class="line">过滤指令</div><div class="line"></div><div class="line">5、&gt;</div><div class="line">重定向符，保存日志到PC上，注意是PC</div></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/07/常用Android工具命令/" data-id="cjal6y3lq001aagvf2nln3o7s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-管理多个ssh-key" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/07/管理多个ssh-key/" class="article-date">
  <time datetime="2017-11-07T00:37:03.000Z" itemprop="datePublished">2017-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/07/管理多个ssh-key/">管理多个ssh key</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、生成key"><a href="#一、生成key" class="headerlink" title="一、生成key"></a>一、生成key</h2><h3 id="1-命令行执行"><a href="#1-命令行执行" class="headerlink" title="1.命令行执行"></a>1.命令行执行</h3><p><code>ssh-keygen -t rsa -C &quot;yourmail@gmail.com&quot;</code> </p>
<h3 id="2-接着提示存储文件名字"><a href="#2-接着提示存储文件名字" class="headerlink" title="2.接着提示存储文件名字"></a>2.接着提示存储文件名字</h3><p>我的命名规则为<code>id_rsa_xxx</code>。<br><img src="/2017/11/07/管理多个ssh-key/ssh-keygen.png" alt="ssh-keygen"></p>
<h3 id="3-之后可以一直回车结束"><a href="#3-之后可以一直回车结束" class="headerlink" title="3.之后可以一直回车结束"></a>3.之后可以一直回车结束</h3><h2 id="二、配置key"><a href="#二、配置key" class="headerlink" title="二、配置key"></a>二、配置key</h2><h3 id="1-命令行执行-1"><a href="#1-命令行执行-1" class="headerlink" title="1.命令行执行"></a>1.命令行执行</h3><p><code>ssh-add ~/.ssh/id_rsa_xxx</code><br><code>id_rsa_xxx</code>是指你在上述步骤生成的密钥文件名。</p>
<h3 id="2-创建config文件"><a href="#2-创建config文件" class="headerlink" title="2.创建config文件"></a>2.创建config文件</h3><ul>
<li>进入.ssh文件夹，创建一个文本文件，命名为config。</li>
<li>每一个key可以按照一下格式加到config文件，#号代表注释。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># github</div><div class="line">Host github</div><div class="line">HostName github.com</div><div class="line">User git</div><div class="line">IdentityFile ~/.ssh/id_rsa_github</div></pre></td></tr></table></figure>
<h2 id="三、测试key"><a href="#三、测试key" class="headerlink" title="三、测试key"></a>三、测试key</h2><h3 id="1-远程仓库配置ssh-key"><a href="#1-远程仓库配置ssh-key" class="headerlink" title="1.远程仓库配置ssh key"></a>1.远程仓库配置ssh key</h3><p>这个请自行搜索。</p>
<h3 id="2-本地测试是否连通"><a href="#2-本地测试是否连通" class="headerlink" title="2.本地测试是否连通"></a>2.本地测试是否连通</h3><ul>
<li>命令行执行<code>ssh -T github</code></li>
<li><code>github</code>是在config文件中定义的Host字段。</li>
<li>测试成功会出现以下提示：<br><img src="/2017/11/07/管理多个ssh-key/ssh -T.png" alt="ssh -T"></li>
</ul>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><ul>
<li>如何在finder中查看.ssh，请搜索mac如何显示隐藏文件。</li>
<li>查看ssh版本<code>ssh -V</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/07/管理多个ssh-key/" data-id="cjal6y3lu001gagvf64st2t9t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Git/">Git</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Git/" style="font-size: 16.67px;">Git</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/Kotlin/" style="font-size: 13.33px;">Kotlin</a> <a href="/tags/环境配置/" style="font-size: 10px;">环境配置</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/11/27/CoordinatorLayout的使用/">CoordinatorLayout的使用</a>
          </li>
        
          <li>
            <a href="/2017/11/25/深入理解Android卷一笔记/">深入理解Android卷一笔记</a>
          </li>
        
          <li>
            <a href="/2017/11/23/Effective-Java笔记/">Effective Java笔记</a>
          </li>
        
          <li>
            <a href="/2017/11/19/Glide笔记/">Glide笔记</a>
          </li>
        
          <li>
            <a href="/2017/11/19/android使用kotlin注意事项/">android使用kotlin注意事项</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 JoKing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>