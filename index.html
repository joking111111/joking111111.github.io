<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JoKing</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JoKing">
<meta property="og:url" content="https://joking111111.github.io/index.html">
<meta property="og:site_name" content="JoKing">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JoKing">
  
    <link rel="alternate" href="/atom.xml" title="JoKing" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoKing</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://joking111111.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Android应用UI性能分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/16/Android应用UI性能分析/" class="article-date">
  <time datetime="2017-12-16T02:21:37.000Z" itemprop="datePublished">2017-12-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/16/Android应用UI性能分析/">Android应用UI性能分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、UI性能分析概述"><a href="#一、UI性能分析概述" class="headerlink" title="一、UI性能分析概述"></a>一、UI性能分析概述</h2><p>目标：</p>
<p>在中低端手机上UI帧率平稳连贯。</p>
<h3 id="1-十六毫秒准则"><a href="#1-十六毫秒准则" class="headerlink" title="1.十六毫秒准则"></a>1.十六毫秒准则</h3><ul>
<li><p>一般Android设备的屏幕刷新率为60帧每秒，那么一帧的时间为1/60fps = 16.6ms。</p>
</li>
<li><p>所谓的掉帧现象指的是，某一帧的等待数据时间加上绘制图像时间超过16.6ms时，这一帧会被放弃掉，不出现在频幕上，取而代之的是下一帧。</p>
</li>
</ul>
<h3 id="2-系统对UI的优化"><a href="#2-系统对UI的优化" class="headerlink" title="2.系统对UI的优化"></a>2.系统对UI的优化</h3><ul>
<li>软解时代：2.3及之前，所有绘图由CPU完成。</li>
<li>硬解时代：2.3之后，系统增加了GPU，很多绘图操作交给GPU进行渲染。</li>
<li>黄油时代：4.1之后，通过VSYNC垂直同步机制和多缓冲机制（three frame buffer）进一步提高绘制效率。</li>
<li>异步绘制时代：5.0之后，系统增加了Render Thread。通过这个线程进行异步绘制，某一帧发生延迟也不会影响下一帧的绘制。</li>
</ul>
<h3 id="3-编写布局准则"><a href="#3-编写布局准则" class="headerlink" title="3.编写布局准则"></a>3.编写布局准则</h3><ul>
<li><p>LinearLayout和RelativeLayout对比</p>
<ul>
<li>LinearLayout优点在于测量方式简单，测量耗时较短，但由于功能简单，通常需要嵌套布局才能实现想要的效果。</li>
<li>RelativeLayout优点在于能实现扁平化布局，缺点在于布局越复杂，测量的耗时增加不少，并且有可能需要多次测量。</li>
</ul>
</li>
<li><p>尽量少嵌套布局。<br>  因为系统绘制一个ViewGroup时，会采用深度优先遍历遍历每一个子View，所以层级越深，耗费时间是指数增长的。</p>
</li>
<li><p>尽量少编写测量复杂的布局。<br>  测量复杂的布局如RelativeLayout过多子View，会导致系统需要多次测量才能确定这些View的尺寸。所以极致扁平化布局有可能得不偿失。</p>
</li>
<li><p>终极目标：尽量减少View的数量。<br>  无论对应减少测量时间以及绘制时间还有内存占用都是有帮助的！</p>
</li>
</ul>
<h2 id="二、性能检测工具"><a href="#二、性能检测工具" class="headerlink" title="二、性能检测工具"></a>二、性能检测工具</h2><h3 id="1-Hierarcy-Viewer"><a href="#1-Hierarcy-Viewer" class="headerlink" title="1.Hierarcy Viewer"></a>1.Hierarcy Viewer</h3><p>首先打开Android Device Monitor：SDK目录-&gt;tools-&gt;monitor。</p>
<p>然后观察窗口顶栏有个带加号窗口按钮，点开发现有Hierarcy Viewer选项。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/12/16/Android应用UI性能分析/" data-id="cjb8v9bkd0003iivf4bpdco9u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SpannableString及其相关类的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/15/SpannableString及其相关类的使用/" class="article-date">
  <time datetime="2017-12-15T00:32:29.000Z" itemprop="datePublished">2017-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/15/SpannableString及其相关类的使用/">SpannableString及其相关类的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、继承关系"><a href="#一、继承关系" class="headerlink" title="一、继承关系"></a>一、继承关系</h2><p><img src="/2017/12/15/SpannableString及其相关类的使用/继承关系.png" alt="继承关系"><br>由于TextView.setText(CharSequence text)接收参数类型为CharSequence，所以他们都能作为setText的参数使用。</p>
<h2 id="二、主要方法"><a href="#二、主要方法" class="headerlink" title="二、主要方法"></a>二、主要方法</h2><h3 id="1-setSpan-Object-what-int-start-int-end-int-flags"><a href="#1-setSpan-Object-what-int-start-int-end-int-flags" class="headerlink" title="1.setSpan(Object what, int start, int end, int flags)"></a>1.setSpan(Object what, int start, int end, int flags)</h3><p>参数含义：</p>
<ul>
<li>what 各种Span样式。</li>
<li>start 改变样式的字符起点，就是要改的第一个下标。</li>
<li>end 改变样式的字符终点，就是要改的最后一个下标的下一个下标。<br>通常end = start + length。</li>
<li>flags 标记位，用于标记修改字符串前后的字符的变化规则。</li>
<li>注意这里中文一个字算一个字符。</li>
</ul>
<p>what参数：</p>
<ul>
<li><p>常用类型</p>
<ul>
<li>ForegroundColorSpan 文本颜色</li>
<li>BackgroundColorSpan 文本背景色</li>
<li>URLSpan 文本超链接</li>
<li>UnderlineSpan 下划线</li>
<li>StrikethroughSpan 删除线</li>
<li>ImageSpan 图片</li>
<li>DynamicDrawableSpan 设置图片，基于文本基线或底部对齐。</li>
<li>ClickableSpan 点击事件</li>
</ul>
</li>
<li><p>其他类型</p>
<ul>
<li>StyleSpan 字体样式：粗体、斜体等</li>
<li>MaskFilterSpan 修饰效果，如浮雕模糊(BlurMaskFilter)</li>
<li>RasterizerSpan 光栅效果</li>
<li>TextAppearanceSpan 文本外貌（包括字体、大小、样式和颜色）</li>
<li>TypefaceSpan 文本字体</li>
<li>SuggestionSpan 相当于占位符</li>
<li>AbsoluteSizeSpan 文本字体（绝对大小）</li>
<li>RelativeSizeSpan 相对大小（文本字体）</li>
<li>ScaleXSpan 基于x轴缩放</li>
<li>SubscriptSpan 下标（数学公式会用到）</li>
<li>SuperscriptSpan 上标（数学公式会用到）</li>
</ul>
</li>
</ul>
<p>flags参数：</p>
<ul>
<li><p><code>Spannable.SPAN_EXCLUSIVE_INCLUSIVE</code><br>新增前插字符不应用效果，新增后插字符应用效果。</p>
</li>
<li><p><code>Spannable.SPAN_INCLUSIVE_EXCLUSIVE</code><br>新增前插字符应用效果，新增后插字符不应用效果。</p>
</li>
<li><p><code>Spannable.SPAN_INCUJSIVE_INCLUSIVE</code><br>前后新增的字符都应用效果。</p>
</li>
<li><p><code>Spannable.SPAN_EXCLUSIVE_EXCLUSIVE</code><br>前后新增的字符都不应用效果。</p>
</li>
</ul>
<h2 id="三、图解参数"><a href="#三、图解参数" class="headerlink" title="三、图解参数"></a>三、图解参数</h2><h3 id="1-start、end、flags参数图解"><a href="#1-start、end、flags参数图解" class="headerlink" title="1.start、end、flags参数图解"></a>1.start、end、flags参数图解</h3><p><img src="/2017/12/15/SpannableString及其相关类的使用/图解参数.png" alt="图解参数"></p>
<h3 id="2-what参数图解"><a href="#2-what参数图解" class="headerlink" title="2.what参数图解"></a>2.what参数图解</h3><p>由于种类过多就不做了。其实没必要做，你只需要知道你想做什么效果，然后点进该类源码，查看构造函数和其公有方法，自然就了解这个类有什么用了。</p>
<p>了解一个类有什么功能的捷径就是查看源码，本篇文章仅辅助你去理解他们。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/12/15/SpannableString及其相关类的使用/" data-id="cjb8v9bl7001biivfx0acd5dr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-FlexboxLayout的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/11/FlexboxLayout的使用/" class="article-date">
  <time datetime="2017-12-11T14:50:24.000Z" itemprop="datePublished">2017-12-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/11/FlexboxLayout的使用/">FlexboxLayout的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>项目地址：<code>https://github.com/google/flexbox-layout</code></p>
<p>官方文档如是说：FlexboxLayout is a library project which brings the similar capabilities of CSS Flexible Box Layout Module to Android.（FlexboxLayout是类似前端CSS的Flexible Box Layout的Android控件。）</p>
<p>我们可以将它看作LinearLayout的增强版，因为它的子View也是按一定顺序排列的。</p>
<p><img src="/2017/12/11/FlexboxLayout的使用/主轴和副轴.png" alt="主轴和副轴"></p>
<p>现定义以下概念：</p>
<h3 id="1-主轴"><a href="#1-主轴" class="headerlink" title="1.主轴"></a>1.主轴</h3><p>新元素排列方向为主轴。</p>
<h3 id="2-副轴"><a href="#2-副轴" class="headerlink" title="2.副轴"></a>2.副轴</h3><p>与主轴垂直方向为副轴。</p>
<h2 id="二、FlexboxLayout自身属性"><a href="#二、FlexboxLayout自身属性" class="headerlink" title="二、FlexboxLayout自身属性"></a>二、FlexboxLayout自身属性</h2><h3 id="1-flexDirection主轴方向"><a href="#1-flexDirection主轴方向" class="headerlink" title="1.flexDirection主轴方向"></a>1.flexDirection主轴方向</h3><ul>
<li>row （默认）主轴为水平方向，从左到右排列。</li>
<li>row_reverse 主轴为水平方向，从右到左排列。</li>
<li>column 主轴为垂直方向，从上到下排列。</li>
<li>column_reverse 主轴为垂直方向，从下到上排列。</li>
</ul>
<h3 id="2-flexWrap换行方式"><a href="#2-flexWrap换行方式" class="headerlink" title="2.flexWrap换行方式"></a>2.flexWrap换行方式</h3><ul>
<li>nowrap 不换行。（如果位置不足会压缩子元素）</li>
<li>wrap 按正常方向换行。</li>
<li>wrap_reverse 按反方向换行。</li>
</ul>
<h3 id="3-justifyContent主轴对齐模式"><a href="#3-justifyContent主轴对齐模式" class="headerlink" title="3.justifyContent主轴对齐模式"></a>3.justifyContent主轴对齐模式</h3><ul>
<li>flex_start （默认值）左对齐。</li>
<li>flex_end 右对齐。</li>
<li>center 居中。</li>
<li>space_between 首尾Item紧贴边界，Item平分内部空隙。</li>
<li>space_around 每个Item两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。</li>
</ul>
<h3 id="4-alignItems副轴对齐模式"><a href="#4-alignItems副轴对齐模式" class="headerlink" title="4.alignItems副轴对齐模式"></a>4.alignItems副轴对齐模式</h3><ul>
<li>stretch （默认值）占满整个容器的高度。</li>
<li>flex-start 副轴的起点对齐。</li>
<li>flex-end 副轴的终点对齐。</li>
<li>center 副轴的中点对齐。</li>
<li>baseline Item的第一行文字的基线对齐。<br>注意:如果有的Item没有文本基线，那么它的基线默认是左上角。</li>
</ul>
<h3 id="5-alignContent多根主轴对齐模式"><a href="#5-alignContent多根主轴对齐模式" class="headerlink" title="5.alignContent多根主轴对齐模式"></a>5.alignContent多根主轴对齐模式</h3><ul>
<li>stretch （默认值）轴线占满整个交叉轴。</li>
<li>flex_start 与副轴的起点对齐。</li>
<li>flex_end 与副轴的终点对齐。</li>
<li>center 与副轴的中点对齐。</li>
<li>space_between 与副轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space_around 每根主轴线两侧的间隔都相等。轴线之间的间隔比轴线与边框的间隔大一倍。</li>
</ul>
<h2 id="三、FlexboxLayout子元素属性"><a href="#三、FlexboxLayout子元素属性" class="headerlink" title="三、FlexboxLayout子元素属性"></a>三、FlexboxLayout子元素属性</h2><h3 id="1-layout-order-自身排列权重"><a href="#1-layout-order-自身排列权重" class="headerlink" title="1.layout_order 自身排列权重"></a>1.layout_order 自身排列权重</h3><p>给子元素加上该属性后，FlexboxLayout将按负值在前，正值在后，按照从小到大的顺序依次排列子元素。</p>
<h3 id="2-layout-flexGrow-子元素瓜分剩余空间比重"><a href="#2-layout-flexGrow-子元素瓜分剩余空间比重" class="headerlink" title="2.layout_flexGrow 子元素瓜分剩余空间比重"></a>2.layout_flexGrow 子元素瓜分剩余空间比重</h3><p>该属性默认值为0，即不瓜分剩余空间。属性值越大，表示瓜分剩余空间比重越大。</p>
<h3 id="3-layout-flexShrink-空间不足时子元素缩小比重"><a href="#3-layout-flexShrink-空间不足时子元素缩小比重" class="headerlink" title="3.layout_flexShrink 空间不足时子元素缩小比重"></a>3.layout_flexShrink 空间不足时子元素缩小比重</h3><p>该属性默认值为1，即都缩小。属性值越大，表示缩小比例越大。属性值为0时表示不缩小该子元素。</p>
<h3 id="4-layout-alignSelf-自身对齐方式"><a href="#4-layout-alignSelf-自身对齐方式" class="headerlink" title="4.layout_alignSelf 自身对齐方式"></a>4.layout_alignSelf 自身对齐方式</h3><ul>
<li>auto （默认）继承父元素的alignItems属性。</li>
<li>flex_start</li>
<li>center</li>
<li>baseline</li>
<li>stretch</li>
</ul>
<h3 id="5-layout-flexBasisPercent-自身占主轴空间百分比"><a href="#5-layout-flexBasisPercent-自身占主轴空间百分比" class="headerlink" title="5.layout_flexBasisPercent 自身占主轴空间百分比"></a>5.layout_flexBasisPercent 自身占主轴空间百分比</h3><p>属性值填”80%”之类的。</p>
<h2 id="四、FlexboxLayoutManager的使用"><a href="#四、FlexboxLayoutManager的使用" class="headerlink" title="四、FlexboxLayoutManager的使用"></a>四、FlexboxLayoutManager的使用</h2><h3 id="1-设置RecyclerView的LayoutManager"><a href="#1-设置RecyclerView的LayoutManager" class="headerlink" title="1.设置RecyclerView的LayoutManager"></a>1.设置RecyclerView的LayoutManager</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FlexboxLayoutManager manager = new FlexboxLayoutManager(getContext());</div><div class="line">//设置FlexboxLayoutManager的属性，相当于设置父容器属性</div><div class="line">manager.setFlexDirection(FlexDirection.ROW);</div><div class="line">...</div><div class="line"></div><div class="line">recyclerView.setLayoutManager(manager);</div></pre></td></tr></table></figure>
<h3 id="2-设置ViewHolder的LayoutParams"><a href="#2-设置ViewHolder的LayoutParams" class="headerlink" title="2.设置ViewHolder的LayoutParams"></a>2.设置ViewHolder的LayoutParams</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ViewGroup.LayoutParams params = holder.itemView.getLayoutParams();</div><div class="line">if (params instanceof FlexboxLayoutManager.LayoutParams) &#123;</div><div class="line">    FlexboxLayoutManager.LayoutParams lp = (FlexboxLayoutManager.LayoutParams) params;</div><div class="line">    //设置子元素属性</div><div class="line">    lp.setFlexGrow(1f);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="五、参考Demo"><a href="#五、参考Demo" class="headerlink" title="五、参考Demo"></a>五、参考Demo</h3><p>官方Demo非常详细，建议下载体验！</p>
<ul>
<li><a href="https://github.com/google/flexbox-layout" target="_blank" rel="external">https://github.com/google/flexbox-layout</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/12/11/FlexboxLayout的使用/" data-id="cjb8v9bko000hiivff4v4r0d0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-自定义View" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/08/自定义View/" class="article-date">
  <time datetime="2017-12-08T13:17:16.000Z" itemprop="datePublished">2017-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/08/自定义View/">自定义View</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、重要回调方法"><a href="#一、重要回调方法" class="headerlink" title="一、重要回调方法"></a>一、重要回调方法</h2><h3 id="1-初始化时机选择"><a href="#1-初始化时机选择" class="headerlink" title="1.初始化时机选择"></a>1.初始化时机选择</h3><ul>
<li>onFinishInflate    解析完xml后回调</li>
<li>onSizeChanged    组件大小发生改变时回调</li>
</ul>
<h3 id="2-塑形"><a href="#2-塑形" class="headerlink" title="2.塑形"></a>2.塑形</h3><ul>
<li>onMeasure</li>
<li>onLayout</li>
<li>onDraw</li>
<li>setWillNotDraw<ul>
<li>该开关值为true时，android系统会对此View进行优化。</li>
<li>重写onDraw方法的同时，最好在初始化时把这个开关关掉。</li>
</ul>
</li>
</ul>
<h3 id="3-事件处理"><a href="#3-事件处理" class="headerlink" title="3.事件处理"></a>3.事件处理</h3><ul>
<li>dispatchTouchEvent</li>
<li>onInterceptTouchEvent</li>
<li>onTouchEvent</li>
<li>ViewParent#requestDisallowInterceptTouchEvent(boolean)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/12/08/自定义View/" data-id="cjb8v9blh001piivf0o5b7q5t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android安全机制简介" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/08/Android安全机制简介/" class="article-date">
  <time datetime="2017-12-08T13:17:00.000Z" itemprop="datePublished">2017-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/08/Android安全机制简介/">Android安全机制简介</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、代码混淆proguard"><a href="#一、代码混淆proguard" class="headerlink" title="一、代码混淆proguard"></a>一、代码混淆proguard</h2><p>由于java字节码可以被反编译，代码混淆可以混淆关键代码，增加阅读代码难度。同时proguard可以压缩代码、优化编译后的java字节码。</p>
<h2 id="二、应用权限检查"><a href="#二、应用权限检查" class="headerlink" title="二、应用权限检查"></a>二、应用权限检查</h2><p>应用声明的权限需要得到系统和用户的认可</p>
<h2 id="三、签名证书"><a href="#三、签名证书" class="headerlink" title="三、签名证书"></a>三、签名证书</h2><p>Android系统识别App的凭证，App的身份证。</p>
<h2 id="四、Linux内核安全机制"><a href="#四、Linux内核安全机制" class="headerlink" title="四、Linux内核安全机制"></a>四、Linux内核安全机制</h2><p>比如文件访问机制等，权限系统。</p>
<h2 id="五、Android虚拟机沙箱机制"><a href="#五、Android虚拟机沙箱机制" class="headerlink" title="五、Android虚拟机沙箱机制"></a>五、Android虚拟机沙箱机制</h2><p>每个App有与之对应的Uid，分别运行在单独的虚拟机中，与其他应用完全隔离。即使一个应用崩溃，也不会导致其他应用异常。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/12/08/Android安全机制简介/" data-id="cjb8v9bke0004iivf82j0cxec" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CoordinatorLayout的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/27/CoordinatorLayout的使用/" class="article-date">
  <time datetime="2017-11-27T13:45:51.000Z" itemprop="datePublished">2017-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/27/CoordinatorLayout的使用/">CoordinatorLayout的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="1-什么是嵌套滚动机制（NestedScrolling）？"><a href="#1-什么是嵌套滚动机制（NestedScrolling）？" class="headerlink" title="1.什么是嵌套滚动机制（NestedScrolling）？"></a>1.什么是嵌套滚动机制（NestedScrolling）？</h3><p>所谓嵌套滚动其实就是界面布局中包含 一个可滚动的列表 和 一个不可滚动的View，这样在滚动列表时，首先将不可滚动View移出屏幕或移进屏幕，待不可滚动View固定时，才会继续滚动滚动列表的内容。</p>
<h3 id="2-为什么要有滑动嵌套机制？"><a href="#2-为什么要有滑动嵌套机制？" class="headerlink" title="2.为什么要有滑动嵌套机制？"></a>2.为什么要有滑动嵌套机制？</h3><p>回想一下android系统事件分发机制，一个down事件到up事件为一个事件流，在这事件流之中一旦某个View拦截（处理）该Touch事件，那么后续这个事件流将统一交由它处理。</p>
<p>有时候我们需要将一个事件流分开成几个事件片给不同的View处理，那么我们需要调配事件分发。滑动嵌套机制应运而生。</p>
<h2 id="二、Android嵌套滚动机制"><a href="#二、Android嵌套滚动机制" class="headerlink" title="二、Android嵌套滚动机制"></a>二、Android嵌套滚动机制</h2><h3 id="1-重要的类"><a href="#1-重要的类" class="headerlink" title="1.重要的类"></a>1.重要的类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NestedScrollingChild接口</div><div class="line">NestedScrollingParent接口</div><div class="line">NestedScrollingChildHelper辅助类</div><div class="line">NestedScrollingParentHelper辅助类</div></pre></td></tr></table></figure>
<h3 id="2-结构图"><a href="#2-结构图" class="headerlink" title="2.结构图"></a>2.结构图</h3><p><img src="/2017/11/27/CoordinatorLayout的使用/结构图.png" alt="结构图"></p>
<h2 id="三、注意事项"><a href="#三、注意事项" class="headerlink" title="三、注意事项"></a>三、注意事项</h2><h3 id="1-子类宽高"><a href="#1-子类宽高" class="headerlink" title="1.子类宽高"></a>1.子类宽高</h3><p>由于CoordinatorLayout是FrameLayout的增强版（官方文档），所以子View使用match_parent这个属性就需要注意了。</p>
<p>如下图，View B使用了match_parent，然后CoordinatorLayout在layout的时候把它的位置下移了，并且超出CoordinatorLayout的区域了。使用clipChildren属性是无效的，clipChildren默认是true的。<br><img src="/2017/11/27/CoordinatorLayout的使用/layout.png" alt="layout"></p>
<h2 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h2><ul>
<li><a href="https://mp.weixin.qq.com/s/GDC3YLLPYsoalr8sg38dmg" target="_blank" rel="external">CoordinatorLayout和Behavior详解</a></li>
<li><a href="https://mp.weixin.qq.com/s/-ldKAMGChfbvk8E8nzvuNw" target="_blank" rel="external">CoordinatorLayout高级用法-自定义Behavior</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/27/CoordinatorLayout的使用/" data-id="cjb8v9bki0009iivf0m7v2q3r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入理解Android卷一笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/25/深入理解Android卷一笔记/" class="article-date">
  <time datetime="2017-11-25T14:52:35.000Z" itemprop="datePublished">2017-11-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/25/深入理解Android卷一笔记/">深入理解Android卷一笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、JNI调用流程分析"><a href="#一、JNI调用流程分析" class="headerlink" title="一、JNI调用流程分析"></a>一、JNI调用流程分析</h2><h3 id="1-Java层"><a href="#1-Java层" class="headerlink" title="1.Java层"></a>1.Java层</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class MediaScanner &#123;</div><div class="line">	static &#123;</div><div class="line">		System.loadLibrary(&quot;media_jni&quot;);</div><div class="line">		native_init();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	private static native void native_init();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>加载对应的JNI库。</li>
<li>声明native函数。</li>
</ul>
<h3 id="2-JNI层"><a href="#2-JNI层" class="headerlink" title="2.JNI层"></a>2.JNI层</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//cpp</div><div class="line">static void android_media_MediaScanner_native_init(JNIEnv *env) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么Java层调用native函数，系统是如何找到JNI层的对应函数的呢？</p>
<h4 id="一、静态注册"><a href="#一、静态注册" class="headerlink" title="一、静态注册"></a>一、静态注册</h4><p>流程：</p>
<ul>
<li>编写java层native函数声明，并javac编译为class文件。</li>
<li>使用<code>javah -o output packagename.classname</code>生成.h头文件。</li>
<li>JNI层cpp或者c文件实现该头文件。</li>
</ul>
<p>当Java层第一次调用该native方法时，jvm会从对应库找对应的头文件。如果找到，保存这个函数指针供下次调用；如果没找到就抛异常。</p>
<p>弊端：</p>
<ul>
<li>修改Java层的native方式后需要重新生成头文件，因为函数签名可能改变了。</li>
<li>初次调用native函数才会去建立关联，有懒加载特性，有利有弊。</li>
</ul>
<h4 id="二、动态注册"><a href="#二、动态注册" class="headerlink" title="二、动态注册"></a>二、动态注册</h4><p>JNI中有一个数据结构专门来记录这种一一对应关系的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">	const char* signature;</div><div class="line">	void* fnPtr;</div><div class="line">&#125; JNINativeMethod;</div></pre></td></tr></table></figure>
<p>AndroidRunTime.cpp提供了registerNativeMethods方法来注册；其中又通过JNIHelp.c的jniRegisterNativeMethods。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jclass clazz = (*env) -&gt; FindClass(env, className);</div><div class="line">(*env) -&gt; RegisterNatives(env, clazz, gMethods, numMethods);</div></pre></td></tr></table></figure>
<ul>
<li>1.当Java层通过System.loadLibrary加载so库时，会先找是否有JNI_OnLoad函数，如果有就调用它；</li>
<li>2.动态注册调用一般写在这个函数里。</li>
</ul>
<p>提示：<br>Android提供了JNIHelp.h这个文件，它内部包含了jni.h，所以我们编写jni时可以直接引入JNIHelp.h。</p>
<h3 id="4-什么是JNIEnv？"><a href="#4-什么是JNIEnv？" class="headerlink" title="4.什么是JNIEnv？"></a>4.什么是JNIEnv？</h3><p>JNIEnv是一个与线程相关的代表JNI环境的结构体。我们经常通过它来从native层回调java层函数，但由于它是线程相关的，所以我们不能在B线程调用A线程的JNIEnv。</p>
<h3 id="5-什么是JavaVM？"><a href="#5-什么是JavaVM？" class="headerlink" title="5.什么是JavaVM？"></a>5.什么是JavaVM？</h3><p>JavaVM顾名思义，就是一个java虚拟机变量，可以比作进程。不管有多少个线程，单进程就单独一个JavaVM。在JNI_OnLoad函数可以获得JavaVM。</p>
<ul>
<li>调用JavaVM-&gt;AttachCurrentThread可以获得当前线程的JNIEnv，这样可以在子线程回调java层函数。</li>
<li>在线程结束时，调用JavaVM-&gt;DetachCurrentThread来释放相关资源。</li>
</ul>
<h3 id="6-什么是jfieldID和jmethodID？"><a href="#6-什么是jfieldID和jmethodID？" class="headerlink" title="6.什么是jfieldID和jmethodID？"></a>6.什么是jfieldID和jmethodID？</h3><p>1.获取：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">jfieldID GetFieldID (jclass clazz, const char* name, const char* sig);</div><div class="line">jmethodID GetMethodID (jclass clazz, const char* name, const char* sig);</div></pre></td></tr></table></figure>
<p>建议在初始化的时候获取并保存下来，提高下一次调用的运行效率。</p>
<p>2.使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">NativeType Call&lt;type&gt;Method (jobject jobj, jmethodID methodID, ...);</div><div class="line">NativeType CallStatic&lt;type&gt;Method (jmethodID methodID, ...);</div><div class="line"></div><div class="line">NativeType Get&lt;type&gt;Field (jobject jobj, jfieldID fieldID);</div><div class="line">void Set&lt;type&gt;Field (jobject jobj, jfieldID fieldID, NativeType value);</div></pre></td></tr></table></figure>
<h3 id="7-jstring"><a href="#7-jstring" class="headerlink" title="7.jstring"></a>7.jstring</h3><p>1.java层String与native层string的转换关系：<br><img src="/2017/11/25/深入理解Android卷一笔记/jstring.png" alt="jstring"></p>
<p>2.释放资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">void ReleaseStringChars(jstring str, char* chs);</div><div class="line">void ReleaseStringUTFChars(jstring str, char* chs);</div></pre></td></tr></table></figure>
<p>转换字符串和释放资源方法应该是成对出现的。</p>
<h3 id="8-JNI类型签名"><a href="#8-JNI类型签名" class="headerlink" title="8.JNI类型签名"></a>8.JNI类型签名</h3><p>命令：<code>javap -s -p xxx.class</code></p>
<p>意义：</p>
<ul>
<li>-s 表示输出内部数据类型的签名信息。 </li>
<li>-p 表示打印所有函数和成员的签名信息。默认只打印public级别。</li>
</ul>
<h3 id="9-引用"><a href="#9-引用" class="headerlink" title="9.引用"></a>9.引用</h3><p>类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1.Local Reference 本地变量</div><div class="line">2.Global Reference 全局变量（强印用）</div><div class="line">3.Weak Global Reference 弱全局变量</div></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">NewGlobalRef(NativeType ref);</div><div class="line">NewWeakGlobalRef(NativeType ref);</div><div class="line"></div><div class="line">DeleteLoaclRef(NativeType ref);</div><div class="line">DeleteGlobalRef(NativeType ref);</div><div class="line">DeleteWeakGlobalRef(NativeType ref);</div></pre></td></tr></table></figure>
<p>有时候我们可能创建太多LocalReference，这样内存占用可观，可以在方法结束调用前，提前手动回收LocalReference。</p>
<h3 id="10-异常"><a href="#10-异常" class="headerlink" title="10.异常"></a>10.异常</h3><p>JNI层可以截获和修改异常。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//JNIEnv方法</div><div class="line">ExceptionOccured 判断是否发生异常</div><div class="line">ExceptionClear 清空当前JNI发生的异常</div><div class="line">ThrowNew 向java层抛异常</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/25/深入理解Android卷一笔记/" data-id="cjb8v9ble001niivf2uev7uwq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Effective-Java笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/23/Effective-Java笔记/" class="article-date">
  <time datetime="2017-11-23T14:42:17.000Z" itemprop="datePublished">2017-11-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/23/Effective-Java笔记/">Effective Java笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、创建和销毁对象"><a href="#一、创建和销毁对象" class="headerlink" title="一、创建和销毁对象"></a>一、创建和销毁对象</h2><h3 id="1-静态工厂方法和公有构造函数"><a href="#1-静态工厂方法和公有构造函数" class="headerlink" title="1.静态工厂方法和公有构造函数"></a>1.静态工厂方法和公有构造函数</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public static Boolean valueOf(boolean b) &#123;</div><div class="line">	return b ? Boolean.TRUE : Boolean.FALSE;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>静态工厂方法名相对构造函数，方便指示使用者选择合适的方法。</li>
<li>静态工厂方法可以控制不创建新对象，而是重复使用一些对象。如示例代码所示。</li>
<li>静态工厂方法可返回返回类型的子类对象，设计模式中的工厂模式。</li>
</ul>
<p>缺点：</p>
<ul>
<li>静态工厂方法一般会把构造函数非公有，导致类不能被继承。但是这样鼓励我们使用组合而非继承。</li>
</ul>
<p>总结：</p>
<ul>
<li>如果需要重用对象（单例），请使用静态工厂方法。</li>
<li>如果需要提供不同的具体实现（子类），或者说面向接口编程，请使用静态工厂方法。</li>
</ul>
<h3 id="2-多个构造函数与Builder（构建者）"><a href="#2-多个构造函数与Builder（构建者）" class="headerlink" title="2.多个构造函数与Builder（构建者）"></a>2.多个构造函数与Builder（构建者）</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public MyView(Context context) &#123;</div><div class="line">       this(context, 100, 100);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyView(Context context, int width, int height) &#123;</div><div class="line">       this(context, width, height);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public MyView(Context context, int width, int height, int margin) &#123;</div><div class="line">		...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>像这种参数比较多，并且有可选参数时，建议使用Builder模式。<br>另外，Builder不建议使用Java Bean的getter、setter形式，建议使用链式调用写法，代码更简洁。</p>
<p>优点：</p>
<ul>
<li>将传入的参数处理职责分离出去，类专注于功能，Builder专注于构建类参数，这样代码可读性跟拓展性增强。</li>
</ul>
<h3 id="3-避免创建不必要的对象"><a href="#3-避免创建不必要的对象" class="headerlink" title="3.避免创建不必要的对象"></a>3.避免创建不必要的对象</h3><p>比如SimpleDateFormat对象。</p>
<h3 id="4-清除过期的对象引用"><a href="#4-清除过期的对象引用" class="headerlink" title="4.清除过期的对象引用"></a>4.清除过期的对象引用</h3><ul>
<li>适当的时候将引用置为null。</li>
<li>使用WeakReference。</li>
</ul>
<h3 id="5-避免使用finalize方法"><a href="#5-避免使用finalize方法" class="headerlink" title="5.避免使用finalize方法"></a>5.避免使用finalize方法</h3><p>原因：</p>
<ul>
<li>jvm不保证对象的finalize方法及时执行。</li>
<li>jvm不保证对象的finalize方法一定执行。</li>
</ul>
<p>建议：</p>
<ul>
<li>在适当的时机，如try-catch中finally代码块调用close、recycle等方法。</li>
</ul>
<h2 id="二、方法的实现"><a href="#二、方法的实现" class="headerlink" title="二、方法的实现"></a>二、方法的实现</h2><h3 id="1-重写equals"><a href="#1-重写equals" class="headerlink" title="1.重写equals"></a>1.重写equals</h3><p>性质：</p>
<ul>
<li>自反性（reflexive） x.equals(x) = true</li>
<li>对称性（symmetric） x.equals(y) &lt;=&gt; y.equals(x)</li>
<li>传递性（transitive） x.equals(y) = y.equals(z) 那么 x.equals(z)结果应为一样</li>
<li>一致性（consistent）x,y不变时，x.equals(y)也不变</li>
<li>非null的x，x.equals(null) = false</li>
</ul>
<p>由于参数固定为Object类型（否则就是方法重载了），有必要做类型检查（instanceOf）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public boolean equals(Object o) &#123;</div><div class="line">       return super.equals(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-重写hashCode"><a href="#2-重写hashCode" class="headerlink" title="2.重写hashCode"></a>2.重写hashCode</h3><p>重写了equals方法后，最好也重写hashCode方法。</p>
<p>原因：</p>
<ul>
<li>两个对象equals方法返回true，不代表两个对象的hashCode返回值相等。</li>
<li>默认hashCode本质上是这个对象的散列值，是以整个对象所有对象生成的，而我们重写equals方法可能只用到对象的关键成员，并不是全体成员。</li>
</ul>
<p>常用的类比如HashMap，我们使用自定义的类作为key时，HashMap会调用key的hashCode方法作为判定key相等的依据之一，并不是重写了equals方法就万事大吉了。</p>
<h3 id="3-重写toString"><a href="#3-重写toString" class="headerlink" title="3.重写toString"></a>3.重写toString</h3><p>可以准备好一份模版或者使用脚本，生成toString函数。<br>比如可以利用toString将Java Bean转换为json字符串。</p>
<h2 id="三、类和接口"><a href="#三、类和接口" class="headerlink" title="三、类和接口"></a>三、类和接口</h2><h3 id="1-组合优于继承"><a href="#1-组合优于继承" class="headerlink" title="1.组合优于继承"></a>1.组合优于继承</h3><p>对于接口的实现和继承不适用这条。</p>
<p>父类有可能因为版本迭代而修改某些方法，这样子类很可能也要做出改变，但是我们可能对具体实现不敏感，只是想增加额外方法。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 接口定义</div><div class="line">*/</div><div class="line">public interface PriceCalculator &#123;</div><div class="line">	float getPrice(int sum);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 包装类</div><div class="line">*/</div><div class="line">public PriceCalculatorWrapper implements PriceCalculator &#123;</div><div class="line">	private PriceCalculator mCalculator;</div><div class="line">	</div><div class="line">	//唯一构造函数</div><div class="line">	public PriceCalculatorWrapper(PriceCalculator calculator) &#123;</div><div class="line">		this.mCalculator = calculator;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	@override</div><div class="line">	public float getPrice(int sum) &#123;</div><div class="line">		return mCalculator.getPrice(sum);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line">* 具体实现类</div><div class="line">*/</div><div class="line">public ShopPriceCalculator implements PriceCalculator &#123;</div><div class="line">	@override</div><div class="line">	public float getPrice(int sum) &#123;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以跟设计模式中的策略模式关联起来。</p>
<h3 id="2-接口优于抽象类"><a href="#2-接口优于抽象类" class="headerlink" title="2.接口优于抽象类"></a>2.接口优于抽象类</h3><ul>
<li>一个类能实现多个接口，只能继承一个类。</li>
<li>面向接口编程，外界知道得越少越好。</li>
<li>接口定义了一类方法的集合，做一件事可能有几个步骤，但是是通过一个接口完成的。</li>
</ul>
<h3 id="3-接口最好只定义方法"><a href="#3-接口最好只定义方法" class="headerlink" title="3.接口最好只定义方法"></a>3.接口最好只定义方法</h3><p>接口虽然可以有静态常量成员变量，但是并不是每个接口的实现类都会用到这些变量。虽然这并不影响运行效率，但是从代码可读性而言，在接口定义静态常量成员变量不是明智之举。</p>
<h3 id="4-使用函数对象实现策略模式"><a href="#4-使用函数对象实现策略模式" class="headerlink" title="4.使用函数对象实现策略模式"></a>4.使用函数对象实现策略模式</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">interface Comparator&lt;T&gt; &#123;</div><div class="line">	int compare(T t1, T t2);</div><div class="line">&#125;</div><div class="line"></div><div class="line">class StringLengthComparator implements Comparator&lt;String&gt; &#123;</div><div class="line">	@override</div><div class="line">	public int compare(String s1, String s2) &#123;</div><div class="line">		return s1.length() - s2.length();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//每一次排序均要创建一个比较函数对象</div><div class="line">Array.sort(stringArray, new StringLengthComparator());</div></pre></td></tr></table></figure>
<p>C++支持函数指针，即把一个函数体用指针作为参数传入别的作用域。这样可以达到面向接口编程的效果，不关注方法的具体实现。而java中，最相似的案例就是回调监听的实现了，只不过java没有指针，而是通过一个实现了监听接口的对象来传入别的作用域。</p>
<p>由于策略模式的方法具体实现是无状态的（上一次调用与下一次调用无关），所以可以考虑将函数对象做成单例。</p>
<p>建议：</p>
<ul>
<li>如果需要频繁使用该函数，那么最好做成一个单例，而不是每一次都创建新对象。</li>
<li>如果使用次数不多，做成单例会导致函数对象生命周期过长，对于内存敏感的程序要慎重，虽然这个单例占用内存可能不多。</li>
</ul>
<h3 id="5-慎用非静态内部类"><a href="#5-慎用非静态内部类" class="headerlink" title="5.慎用非静态内部类"></a>5.慎用非静态内部类</h3><p>匿名内部类也属于非静态内部类。</p>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivty extends ... &#123;</div><div class="line">	public void work() &#123;</div><div class="line">		new Thread() &#123;</div><div class="line">			Toast.makeText(MainActivity.this, &quot;hello world&quot; ,Toast.LENGTH_SHORT);</div><div class="line">			//do something</div><div class="line">			...</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在work函数里面，创建了一个匿名内部类，它持有了外部类的强引用（MainActivity.this）。如果内部类的生命周期比外部类长的话，就会发生内存泄漏。</p>
<p>不仅是内存泄漏，由于内部类有外部类的强引用，也会占用一定内存空间。比如HashMap中的Entry如果不是静态内部类，那么每个Entry都会拥有HashMap的强引用，一旦节点数量多了，也会影响性能。</p>
<p>建议：</p>
<ul>
<li>如果不需要外部类的引用（调用方法），请加上static关键字修饰内部类。</li>
<li>如果需要使用非静态内部类，请谨慎管理非静态内部类对象的生命周期。</li>
</ul>
<h2 id="四、泛型"><a href="#四、泛型" class="headerlink" title="四、泛型"></a>四、泛型</h2><h3 id="1-不要使用原生态类型"><a href="#1-不要使用原生态类型" class="headerlink" title="1.不要使用原生态类型"></a>1.不要使用原生态类型</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//原生态类型</div><div class="line">List list = new ArrayList();</div><div class="line"></div><div class="line">//非原生态类型</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">--------------------------------------------------------------------</div><div class="line"></div><div class="line">//错误代码</div><div class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</div><div class="line">unsafeAdd(list, new Integer(1));</div><div class="line">//crash</div><div class="line">list.get(0);</div><div class="line"></div><div class="line">--------------------------------------------------------------------</div><div class="line">public static void unsafeAdd(List list, Object o)&#123;</div><div class="line">	list.add(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>unsafeAdd方法参数list使用了原生态类型，并没有对插入元素做类型检查。所以在编译期不会报错。</li>
<li>等到调用了get方法时，程序尝试将Integer强转为String，抛出异常。</li>
</ul>
<p>注意！有两种特殊情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//1.获取class类</div><div class="line">List.class,String[].class,int.class 合法</div><div class="line">List&lt;String&gt;,List&lt;?&gt;.class 不合法</div><div class="line"></div><div class="line">//2.类型判定</div><div class="line">if (o instanceOf Set) &#123;</div><div class="line">	Set&lt;?&gt; set = (Set&lt;?&gt;) o;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结：<br>我们应该使用带泛型参数的类，让编译器帮助我们暴露程序的问题，而不是等到程序运行异常才暴露问题。</p>
<h3 id="2-泛型列表优于泛型数组"><a href="#2-泛型列表优于泛型数组" class="headerlink" title="2.泛型列表优于泛型数组"></a>2.泛型列表优于泛型数组</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//运行时报错</div><div class="line">Object[] objects = new Long[1];</div><div class="line">objects[0] = &quot;hello world&quot;;</div><div class="line"></div><div class="line">//编译不通过</div><div class="line">List&lt;Object&gt; list = new ArrayList&lt;Long&gt;();</div><div class="line">list.add(&quot;hello world&quot;);</div></pre></td></tr></table></figure>
<p>原因：</p>
<ul>
<li>Object[]是Long[]的父类，因此分配内存给objects时不会抛异常。</li>
<li>List<object>并不是ArrayList<long>的父类，也不是List<long>的父类，所以编译不通过。</long></long></object></li>
<li>Java泛型使用的是类型擦除机制实现泛型的，运行时把具体类型替换掉。编译期在编译时会做类型检查，这也是使用非原生态类型的好处。</li>
</ul>
<h2 id="五、枚举和注解"><a href="#五、枚举和注解" class="headerlink" title="五、枚举和注解"></a>五、枚举和注解</h2><h3 id="1-用enum代替int常量"><a href="#1-用enum代替int常量" class="headerlink" title="1.用enum代替int常量"></a>1.用enum代替int常量</h3><p>Java枚举类型基本想法：通过public static final为每个枚举常量导出实例的类。</p>
<ul>
<li>枚举没有公有构造函数，所以程序员无法手动创建枚举实例。</li>
<li>枚举是线程安全的（final），也是防序列化反序列化的，很适合做单例。</li>
<li>枚举常量是一个个对象，功能上肯定比一个int常量要强多了，相对的开销也大了。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public enum Sample &#123;</div><div class="line">	SOLO(1), DUET(2), TRIO(3);</div><div class="line">	</div><div class="line">	private final int order;</div><div class="line">	Sample(int order) &#123;</div><div class="line">		this.order = order;</div><div class="line">	&#125;</div><div class="line">	public int getOrder() &#123;</div><div class="line">		return order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不要使用默认顺序和ordinal()函数，而是使用一个成员变量记录序号。因为这样便于维护和检查。</p>
<h3 id="2-坚持使用override注解"><a href="#2-坚持使用override注解" class="headerlink" title="2.坚持使用override注解"></a>2.坚持使用override注解</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">	private int order;</div><div class="line">	public boolean equals (Test t) &#123;</div><div class="line">		return this.order == t.order;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>equals没有使用override注解，导致编译期编译时没有“检查”。事实上，这个equals方法看似是重写，实际上是重载。因为equals方法原型是<code>public boolean equals(Object o)</code>。</p>
<h3 id="3-常用注解"><a href="#3-常用注解" class="headerlink" title="3.常用注解"></a>3.常用注解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@callSuper //声明子类若重写该方法，必须调用父类方法</div></pre></td></tr></table></figure>
<h2 id="六、函数方法"><a href="#六、函数方法" class="headerlink" title="六、函数方法"></a>六、函数方法</h2><h3 id="1-必要时进行保护性拷贝"><a href="#1-必要时进行保护性拷贝" class="headerlink" title="1.必要时进行保护性拷贝"></a>1.必要时进行保护性拷贝</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public class Adapter &#123;</div><div class="line">	private List&lt;String&gt; mList;</div><div class="line">	public Adapter(List&lt;String&gt; list) &#123;</div><div class="line">		mList = list;//没有保护性拷贝</div><div class="line">		mList = new ArrayList(list);//进行保护性拷贝</div><div class="line">		...</div><div class="line">		//检查参数有效性</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一条主要按业务逻辑分的，如果想共用同一个参数对象，那么保存它的引用就好，否则我们应该新创建一个对象对参数对象进行拷贝。</p>
<p>保护性拷贝场景：</p>
<ul>
<li>不希望参数对象在类外部变化时能影响类时。</li>
<li>对并发场景有要求。</li>
</ul>
<h3 id="2-检查参数有效性"><a href="#2-检查参数有效性" class="headerlink" title="2.检查参数有效性"></a>2.检查参数有效性</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@override</div><div class="line">public boolean equals(Object o) &#123;</div><div class="line">	if(o instanceOf String) &#123;</div><div class="line">		String s = (String) o;</div><div class="line">		...</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查参数有效性一般在保护性拷贝之后。方法调用前检查参数合法性，减少调试的复杂性。</p>
<h3 id="3-谨慎增加快捷方法"><a href="#3-谨慎增加快捷方法" class="headerlink" title="3.谨慎增加快捷方法"></a>3.谨慎增加快捷方法</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void showWindow(int width, int height, long time) &#123;</div><div class="line">	...</div><div class="line">&#125;</div><div class="line"></div><div class="line">//快捷方法，宽高默认100</div><div class="line">public void showWindow(long time) &#123;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除非快捷方法经常被调用，否则最好不要写快捷方法。因为增加快捷方法会使类的方法数上升，对于用户的理解难度相对增加；对于维护者，增加了维护默认参数和文档的职责。</p>
<h3 id="4-谨慎使用重载"><a href="#4-谨慎使用重载" class="headerlink" title="4.谨慎使用重载"></a>4.谨慎使用重载</h3><p>这里需要强调重载和重写的运行时机区别：</p>
<ul>
<li>重载方法运行时机是在编译期确定好的，一个参数对象编译期是什么类型，决定了它会走哪个重载方法，并不会它运行时是子类对象而发生改变。</li>
<li>重写方法运行时机是在运行时才确定的，是根据对象的实际类型决定走哪个类的重写方法，不受编译时类型影响。</li>
</ul>
<h3 id="5-谨慎使用可变参数"><a href="#5-谨慎使用可变参数" class="headerlink" title="5.谨慎使用可变参数"></a>5.谨慎使用可变参数</h3><p>弊端：</p>
<ul>
<li>方法调用前得检查参数有效性稍麻烦。</li>
<li>可变参数方法的每次调用都会导致进行一次数组分配和初始化。</li>
</ul>
<p>建议：</p>
<ul>
<li>根据调用频率，给频率高的方法提供单独方法，对于频率低的可以使用可变参数方法。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public void foo() &#123; &#125;</div><div class="line">public void foo(int a1) &#123; &#125;</div><div class="line">public void foo(int a1, int a2) &#123; &#125;</div><div class="line">public void foo(int a1, int a2, int a3) &#123; &#125;</div><div class="line">public void foo(int a1, int a2, int a3, int... rest) &#123; &#125;</div></pre></td></tr></table></figure>
<h3 id="6-返回长度为零的数组或集合，而不是null"><a href="#6-返回长度为零的数组或集合，而不是null" class="headerlink" title="6.返回长度为零的数组或集合，而不是null"></a>6.返回长度为零的数组或集合，而不是null</h3><p>原因：</p>
<ul>
<li>返回null调用者需要对null作额外处理。当然调用者也需要对零长度作处理。</li>
<li>零长度的数组或集合创建开销并不大。</li>
<li>零长度的数组属于不可变的（final），可以共享。</li>
</ul>
<h2 id="七、通用程序设计"><a href="#七、通用程序设计" class="headerlink" title="七、通用程序设计"></a>七、通用程序设计</h2><h3 id="1-尽量使用for-each而不是for循环和使用Iterator"><a href="#1-尽量使用for-each而不是for循环和使用Iterator" class="headerlink" title="1.尽量使用for-each而不是for循环和使用Iterator"></a>1.尽量使用for-each而不是for循环和使用Iterator</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//for-each</div><div class="line">for(String s : list) &#123;</div><div class="line">	doSomething(s);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//for循环</div><div class="line">for(int i = 0;i &lt; a.length; i++) &#123;</div><div class="line">	doSomething(a[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//Iterator</div><div class="line">for(Iterator&lt;String&gt; i = list.iterator(); i.hasNext(); ) &#123;</div><div class="line">	doSomething(i.next());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>代码简洁。</li>
<li>性能较好，只计算一次size。</li>
</ul>
<h3 id="2-基本类型优于装箱基本类型"><a href="#2-基本类型优于装箱基本类型" class="headerlink" title="2.基本类型优于装箱基本类型"></a>2.基本类型优于装箱基本类型</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//自动装箱</div><div class="line">Integer integer = 10;</div><div class="line">//自动拆箱</div><div class="line">int i = integer;</div></pre></td></tr></table></figure>
<p>对照关系：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">byte - Byte</div><div class="line">int - Integer</div><div class="line">long - Long</div><div class="line">boolean - Boolean</div><div class="line">float - Float</div><div class="line">double - Double</div></pre></td></tr></table></figure>
<ul>
<li><p>自动装箱是基本数据类型自动转换为装箱基本类型，是java语法糖。它伴随着新对象的生成，当然有性能损耗。</p>
</li>
<li><p>自动拆箱是调用装箱基本类型对象的取值方法。</p>
</li>
</ul>
<h3 id="3-如果需要精确值，避免使用float和double"><a href="#3-如果需要精确值，避免使用float和double" class="headerlink" title="3.如果需要精确值，避免使用float和double"></a>3.如果需要精确值，避免使用float和double</h3><ul>
<li><p>float和double执行二进制浮点运算，这是为了在广泛的数值范围上提供较为精确的快速近似计算而精心设计的。</p>
</li>
<li><p>然而他们并没有提供完全精确的结果，所以不应该被用于需要精确结果的场合。</p>
</li>
</ul>
<p>需要准确结果，请使用BigDecimal类，它额外提供了几种四舍五入的模式。</p>
<h3 id="4-慎用String连接"><a href="#4-慎用String连接" class="headerlink" title="4.慎用String连接"></a>4.慎用String连接</h3><p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">String str = &quot;hello&quot; + &quot;world&quot;;</div></pre></td></tr></table></figure>
<p>这里涉及到三个对象生成。</p>
<ul>
<li><p>String是不可变的（final），一旦一个String对象生成，它本身是不会发生改变的。</p>
</li>
<li><p>String相加其实是语法糖，运算符重载。</p>
</li>
<li><p>三个对象分别为”hello”、”world”、”helloworld”。</p>
</li>
</ul>
<h2 id="八、异常"><a href="#八、异常" class="headerlink" title="八、异常"></a>八、异常</h2><h3 id="1-不要滥用异常机制"><a href="#1-不要滥用异常机制" class="headerlink" title="1.不要滥用异常机制"></a>1.不要滥用异常机制</h3><p>有时代码抛出异常，如果无法快速找到修复方法，我们为了尽快修复，可能会使用try-catch来暂时避免程序崩溃。我们应尽量不使用try-catch来捕获处理异常，而是通过代码逻辑来判断异常发生。</p>
<h3 id="2-使用try-catch时，请尽量缩小代码块范围"><a href="#2-使用try-catch时，请尽量缩小代码块范围" class="headerlink" title="2.使用try-catch时，请尽量缩小代码块范围"></a>2.使用try-catch时，请尽量缩小代码块范围</h3><p>异常机制是在jvm层面实现的，try-catch代码块会阻止jvm执行某些特定优化，导致程序运行效率下降。</p>
<p>最常见的情况就是打开文件做文件操作时，某些程序员为了省事直接用try-catch把方法开始到方法结束包住，因为他们并不知道这样的写法会导致程序运行效率下降。</p>
<p>正确的做法应该是尽量减少try-catch代码块的长度，宁愿多用几个try-catch代码块，也不要一个try-catch代码块将全部代码包住。</p>
<h3 id="3-throw明确异常，catch明确异常"><a href="#3-throw明确异常，catch明确异常" class="headerlink" title="3.throw明确异常，catch明确异常"></a>3.throw明确异常，catch明确异常</h3><p>对异常进行分类抛出和处理，便于日后维护。</p>
<h2 id="九、序列化"><a href="#九、序列化" class="headerlink" title="九、序列化"></a>九、序列化</h2><h3 id="1-Serializable"><a href="#1-Serializable" class="headerlink" title="1.Serializable"></a>1.Serializable</h3><p>需要序列化的类（如java bean）才实现Serializable，因为实现一个接口总是有代价的。</p>
<h3 id="2-Parcelable"><a href="#2-Parcelable" class="headerlink" title="2.Parcelable"></a>2.Parcelable</h3><p>这个接口是android特有的，出现的原因之一是解决因为本地序列化反序列化耗时较长导致某些重要操作耗时变长。它不能本地化（序列化到本地文件），而是序列化到内存中。相对于Serializable，其实不能相提并论，因为使用场景不一样。</p>
<p>比如，Activity#onSaveInstanceState(Bundle state)、Activity#onRestoreInstanceState(Bundle state)这两个方法，需要对Activity的状态保存或重建，对速度要求高，对本地化存储没有要求。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/23/Effective-Java笔记/" data-id="cjb8v9bkl000ciivfyos2aw8c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Glide笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/19/Glide笔记/" class="article-date">
  <time datetime="2017-11-19T06:23:15.000Z" itemprop="datePublished">2017-11-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/19/Glide笔记/">Glide笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一-基本组件"><a href="#一-基本组件" class="headerlink" title="一.基本组件"></a>一.基本组件</h2><h3 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1.基本使用"></a>1.基本使用</h3><p>以下均基于Glide4.x版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//加载图片</div><div class="line">Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options)</div><div class="line">.into(imageView);</div><div class="line"></div><div class="line">//取消加载</div><div class="line">Glide.with(getContext())</div><div class="line">.clear(imageView);</div></pre></td></tr></table></figure>
<h3 id="2-RequestOptions"><a href="#2-RequestOptions" class="headerlink" title="2.RequestOptions"></a>2.RequestOptions</h3><p>Glide的常用选项</p>
<ul>
<li>裁剪样式circleCrop、circleCrop等。</li>
<li>加载中占位图placeholder</li>
<li>加载失败图error</li>
<li>…</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RequestOptions centerCropOptions = new RequestOptions()</div><div class="line">            .centerCrop()</div><div class="line">            .placeholder(R.drawable.img_loading)</div><div class="line">            .error(R.drawable.img_failed);</div></pre></td></tr></table></figure>
<h3 id="3-RequestBuilder"><a href="#3-RequestBuilder" class="headerlink" title="3.RequestBuilder"></a>3.RequestBuilder</h3><p>可以理解为一个个的请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">RequestBuilder builder = Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options);</div></pre></td></tr></table></figure>
<p>当调用RequestBuilder.into(target)时开始加载。这个方法的返回值类型不再是RequestBuilder了。</p>
<h2 id="二、常用操作"><a href="#二、常用操作" class="headerlink" title="二、常用操作"></a>二、常用操作</h2><h3 id="1-加载失败回调监听"><a href="#1-加载失败回调监听" class="headerlink" title="1.加载失败回调监听"></a>1.加载失败回调监听</h3><p>RequestBuilder.listen(RequestListener)方法监听load成功还是失败。</p>
<ul>
<li>注意这里不能在监听里对同一个target（imageView）发起加载请求，因为当前请求尚未结束，会抛出异常。</li>
<li>所以无法使用这个监听实现加载失败时加载备用url的需求。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Glide.with(getContext())</div><div class="line">.load(url)</div><div class="line">.apply(options)</div><div class="line">.listener(new RequestListener() &#123;</div><div class="line">	@Override</div><div class="line">	public boolean onLoadFailed(@Nullable GlideException e, Object model, Target target, boolean isFirstResource) &#123;</div><div class="line">		//false：事件继续往下传递</div><div class="line">		//true：事件不再往下传递</div><div class="line">   		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	@Override</div><div class="line">	public boolean onResourceReady(Object resource, Object model, Target target, DataSource dataSource, boolean isFirstResource) &#123;</div><div class="line">		//false：事件继续往下传递</div><div class="line">		//true：事件不再往下传递</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">&#125;)</div><div class="line">.into(imageView);</div></pre></td></tr></table></figure>
<h3 id="2-请求失败后启用备用请求"><a href="#2-请求失败后启用备用请求" class="headerlink" title="2.请求失败后启用备用请求"></a>2.请求失败后启用备用请求</h3><p>RequestBuilder.error(RequestBuilder)方法可以在这个request失败后启用备用的request。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">RequestBuilder builder1 = Glide.with(getContext())</div><div class="line">.load(url1)</div><div class="line">.apply(options);</div><div class="line"></div><div class="line">RequestBuilder builder2 = Glide.with(getContext())</div><div class="line">.load(url2)</div><div class="line">.apply(options)</div><div class="line">.error(builder1);</div><div class="line"></div><div class="line">builder2.into(imageView);</div></pre></td></tr></table></figure>
<p>这段代码意义为当url2加载失败后，会启用builder1这个请求，加载url1。这样我们就可以实现多级url加载了。</p>
<p>以下为多级加载url方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public static void loadUrls(String[] urls, RequestOptions options, ImageView imageView) &#123;</div><div class="line">        if (urls == null || urls.length == 0) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        RequestBuilder&lt;Drawable&gt; frontBuilder = Glide.with(getContext()).load(urls[0]).apply(options);</div><div class="line">        RequestBuilder&lt;Drawable&gt; prevBuilder = frontBuilder;</div><div class="line">        </div><div class="line">        for (int i = 1; i &lt; urls.length; i++) &#123;</div><div class="line">            RequestBuilder&lt;Drawable&gt; nextBuilder = Glide.with(getContext()).load(urls[i]).apply(options);</div><div class="line">            prevBuilder.error(nextBuilder);</div><div class="line">            prevBuilder = nextBuilder;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        frontBuilder.into(imageView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://joking111111.github.io/2017/11/19/Glide笔记/" data-id="cjb8v9bkv000siivfpju2ulvx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin/">Kotlin</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/环境配置/">环境配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Git/" style="font-size: 16.67px;">Git</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/Kotlin/" style="font-size: 13.33px;">Kotlin</a> <a href="/tags/环境配置/" style="font-size: 10px;">环境配置</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/12/16/Android应用UI性能分析/">Android应用UI性能分析</a>
          </li>
        
          <li>
            <a href="/2017/12/15/SpannableString及其相关类的使用/">SpannableString及其相关类的使用</a>
          </li>
        
          <li>
            <a href="/2017/12/11/FlexboxLayout的使用/">FlexboxLayout的使用</a>
          </li>
        
          <li>
            <a href="/2017/12/08/自定义View/">自定义View</a>
          </li>
        
          <li>
            <a href="/2017/12/08/Android安全机制简介/">Android安全机制简介</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 JoKing<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>